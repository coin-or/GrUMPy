<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>coinor.grumpy.BBTree API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>coinor.grumpy.BBTree</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from future import standard_library
standard_library.install_aliases()
from builtins import str
from builtins import hex
from builtins import range
from past.utils import old_div
# BBTree.py
#
#  Copyright 2009, 2010 Google Inc.
#  Copyright 2007 University of Pittsburgh.
#  Copyright 2012, 2013 Lehigh University
#  Google coding done by Brady Hunsaker.
#  U of Pittsburgh coding done by Osman Ozaltin and Brady Hunsaker.
#  Lehigh University coding done by Ted Ralphs and Aykut Bulut
#
#  This file was part of BAK (Branch-and-bound Analysis Kit).
#  It has now been incporporated into GrUMPy (Graphics for Understanding
#  Mathematical Programming in Python).
#
#  The contents of this file are subject to the Eclipse Public License
#  1.0.  (the &#34;License&#34;); you may not use this file except in
#  compliance with the License. You should have received a copy of
#  the Common Public License along with STOP.
#
#  Software distributed under the License is distributed on an &#34;AS
#  IS&#34; basis, WITHOUT WARRANTY OF ANY KIND, either express or
#  implied. See the License for the specific language governing
#  rights and limitations under the License.
#
# For developers: Please keep the code style consistent with the Python
# style guide for Google&#39;s Summer of Code, except use 4 spaces to indent:
#   http://code.google.com/p/soc/wiki/PythonStyleGuide

__author__ = &#39;Brady Hunsaker, Osman Ozaltin, Ted Ralphs, Aykut Bulut&#39;
__maintainer__ = &#39;Aykut Bulut (aykut@lehigh.edu)&#39;

&#34;&#34;&#34;
This package is for visualizing branch-and-bound. It also contains
a basic branch-and-bound implementation primarily for classroom and educational
use.

Communication with solvers is through a grammar described in separate
documentation. Solvers can interface to this class in a number of
different ways and a number of different types of images may be created.

Images at intervals that can be specified on the command line as well as after
new incumbent solutions are found.

Note that the generation of tree images takes significantly longer than other
images because every node appears in the image.
&#34;&#34;&#34;

import math
import random
import re
import subprocess
import sys, os
import tempfile
import optparse
try:
    from src.gimpy import BinaryTree, XDOT_INSTALLED, MATPLOTLIB_INSTALLED, DOT2TEX_INSTALLED
    from src.gimpy import PIL_INSTALLED, ETREE_INSTALLED
    from src.gimpy import quote_if_necessary as quote
except ImportError:
    from coinor.gimpy import BinaryTree, XDOT_INSTALLED, MATPLOTLIB_INSTALLED, DOT2TEX_INSTALLED
    from coinor.gimpy import PIL_INSTALLED, ETREE_INSTALLED
    from coinor.gimpy import quote_if_necessary as quote
from io import StringIO
from pulp import LpVariable, lpSum, LpProblem, LpMaximize, LpConstraint
from pulp import LpStatus, value
from .forecasting import ForecastingChainedSequences

if MATPLOTLIB_INSTALLED:
    import matplotlib.pyplot as plt

if PIL_INSTALLED:
    from PIL import Image as PIL_Image

# branch strategy
BRANCH_STRATEGY = None
# search strategy
SEARCH_STRATEGY = None
# branching strategies
MOST_FRACTIONAL = &#39;Most Fraction&#39;
FIXED_BRANCHING = &#39;Fixed Branching&#39;
PSEUDOCOST_BRANCHING = &#39;Pseudocost Branching&#39;
# search strategies
DEPTH_FIRST = &#39;Depth First&#39;
BEST_FIRST = &#39;Best First&#39;
BEST_ESTIMATE = &#39;Best Estimate&#39;
INFINITY = sys.maxsize

DOT2TEX_TEMPLATE = r&#39;&#39;&#39;
\documentclass[landscape]{article}
\usepackage[x11names, rgb]{xcolor}
\usepackage[&lt;&lt;textencoding&gt;&gt;]{inputenc}
\usepackage{tikz}
\usetikzlibrary{snakes,arrows,shapes}
\usepackage{amsmath}
\usepackage[margin=2cm,nohead]{geometry}%
&lt;&lt;startpreprocsection&gt;&gt;%
\usepackage[active,auctex]{preview}
&lt;&lt;endpreprocsection&gt;&gt;%
&lt;&lt;gvcols&gt;&gt;%
&lt;&lt;cropcode&gt;&gt;%
&lt;&lt;docpreamble&gt;&gt;%

\begin{document}
\pagestyle{empty}
%
&lt;&lt;startpreprocsection&gt;&gt;%
&lt;&lt;preproccode&gt;&gt;
&lt;&lt;endpreprocsection&gt;&gt;%
%
&lt;&lt;startoutputsection&gt;&gt;
\enlargethispage{100cm}
% Start of code
% \begin{tikzpicture}[anchor=mid,&gt;=latex&#39;,join=bevel,&lt;&lt;graphstyle&gt;&gt;]
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[&gt;=latex&#39;,join=bevel,&lt;&lt;graphstyle&gt;&gt;]
\pgfsetlinewidth{1bp}
&lt;&lt;figpreamble&gt;&gt;%
&lt;&lt;drawcommands&gt;&gt;
&lt;&lt;figpostamble&gt;&gt;%
\end{tikzpicture}
% End of code
}
&lt;&lt;endoutputsection&gt;&gt;
%
\end{document}
%
&lt;&lt;startfigonlysection&gt;&gt;
\begin{tikzpicture}[&gt;=latex,join=bevel,&lt;&lt;graphstyle&gt;&gt;]
\pgfsetlinewidth{1bp}
&lt;&lt;figpreamble&gt;&gt;%
&lt;&lt;drawcommands&gt;&gt;
&lt;&lt;figpostamble&gt;&gt;%
\end{tikzpicture}
&lt;&lt;endfigonlysection&gt;&gt;
&#39;&#39;&#39;

class BBTree(BinaryTree):
    &#34;&#34;&#34;
    Methods to process and visualize information about a b&amp;b tree. It can
    process an output file (in a specific format, see BAK project in COIN-OR) of
    a solver that has three information. See run.py in examples directory fot
    this use. Moreover it implements a branch and bound method that can solve
    binary programs (0-1 variables only) using PuLP as an LP solver. It provides
    different branching and searching strategies. See test_strategies.py in test
    directory.

    This is the main class of GrUMPy. It inherits BinaryTree from GIMPy and
    keeps the entire branch-and-bound tree in self.
    &#34;&#34;&#34;
    def __init__(self, **attrs):
        if not &#39;layout&#39; in attrs:
            attrs[&#39;layout&#39;]= &#39;bak&#39;
        BinaryTree.__init__(self, **attrs)
        # User-controlled constant values
        self._label = &#39;&#39;
        self._filename = None
        self._logscaley = False
        self._fathom = False
        self._wait_for_keypress = True
        self._edge_limit = 1000000
        # current time, updated each time we read a new line
        self._time = 0.0
        # use at most NUM nodes of each type in tree images; zero means no limit
        self._sample_tree = 0
        # Instance-dependent constant values
        self._optimization_sense = None
        self._start_time = None
        self._histogram_lower_bound = None
        self._histogram_upper_bound = None
        self._scatterplot_lower_bound = None
        self._scatterplot_upper_bound = None
        self._integer_infeasibility_lower_bound = None
        self._integer_infeasibility_upper_bound = None
        # Changing reference values
        self._image_counter = 0
        self._next_image_time = None
        self._incumbent_value = None
        self._incumbent_parent = None
        self._new_integer_solution = False
        self._max_objective_value = None
        self._min_objective_value = None
        self._max_integer_infeasibility_sum = None
        # List of incumbent path data files, for the all incumbent paths image
        self._incumbent_path_datafiles = []
        # Objects for measuring and predicting progress
        self._objective_gap_forecaster = ForecastingChainedSequences()
        self._sum_subtree_gaps_forecaster = ForecastingChainedSequences()
        self._sum_subtree_gaps_scale = 1.0
        self._previous_incumbent_value = None  # Only needed for SSG
        if &#39;display&#39; in attrs:
            self.set_display_mode(attrs[&#39;display&#39;])
        else:
            self.set_display_mode(&#39;off&#39;)

    def process_file(self, file_name):
        self._filename = file_name
        input_file = open(file_name, &#39;r&#39;)
        # Parse all the lines
        for line in input_file:
            self.ProcessLine(line)
            if self.root is not None:
                self.display()
        input_file.close()

    def write_as_dynamic_gexf(self, filename, mode = &#34;Dot&#34;):
        if not GEXF_INSTALLED:
            print(&#39;Gexf not installed. Exiting.&#39;)
            return
        if mode == &#39;Dot&#39;:
            try:
                gexf = Gexf(&#34;Mike O&#39;Sullivan&#34;, &#34;Dynamic graph file&#34;)
                graph = gexf.addGraph(&#34;directed&#34;, &#34;dynamic&#34;, &#34;Dynamic graph&#34;)
                objAtt = graph.addNodeAttribute(&#34;obj&#34;, &#34;0.0&#34;, &#34;float&#34;)
                currAtt = graph.addNodeAttribute(&#34;current&#34;, &#34;1.0&#34;,
                                                 &#34;integer&#34;, &#34;dynamic&#34;)
                node_names = self.get_node_list()
                for name in node_names:
                    node = self.get_node(name)
                    if node.get(&#34;step&#34;) is None:
                        raise Exception(&#34;Node without step in BBTree&#34;,
                                        &#34;node =&#34;, node)
                    curr_step = &#39;%s&#39; % node.get(&#34;step&#34;)
                    next_step = &#34;%s&#34; % (node.get(&#34;step&#34;) + 1)
                    n = graph.addNode(name, node.get_label(), start=curr_step)
                    if node.get(&#34;obj&#34;) is None:
                        raise Exception(&#34;Node without objective in BBTree&#34;,
                                        &#34;node =&#34;, node)
                    n.addAttribute(objAtt, &#34;%s&#34; % node.get(&#34;obj&#34;))
                    n.addAttribute(currAtt, &#34;1&#34;, start=curr_step, end=next_step)
                    n.addAttribute(currAtt, &#34;0&#34;, start=next_step)
                edge_names = self.get_edge_list()
                for i, (m_name, n_name) in enumerate(edge_names):
                    edge = self.get_edge(m_name, n_name)
                    if edge.get(&#34;step&#34;) is None:
                        raise Exception(&#34;Edge without step in BBTree&#34;,
                                        &#34;edge =&#34;, (m_name, n_name))
                    curr_step = &#34;%s&#34; % edge.get(&#34;step&#34;)
                    graph.addEdge(i, m_name, n_name, start=curr_step)
                output_file = open(filename + &#34;.gexf&#34;, &#34;w&#34;)
                gexf.write(output_file)
            except Exception as e:
                print(e)
                print(&#34;No .gexf file created&#34;)
        else:
            raise Exception(&#34;Only Dot mode supported in write_as_dynamic_gexf&#34;)

    def set_display_mode(self, mode):
        if mode is &#39;off&#39;:
            self.attr[&#39;display&#39;] = mode
        elif mode is &#39;matplotlib&#39;:
            if MATPLOTLIB_INSTALLED:
                self.attr[&#39;display&#39;] = &#39;matplotlib&#39;
            else:
                print(&#39;Matplotlib is not installed. Display is set to off.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif mode is &#39;PIL&#39;:
            if PIL_INSTALLED:
                self.attr[&#39;display&#39;] = &#39;PIL&#39;
            else:
                print(&#39;PIL is not installed. Display is set to off.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif mode is &#39;xdot&#39;:
            if XDOT_INSTALLED:
                self.attr[&#39;display&#39;] = &#39;xdot&#39;
            else:
                print(&#39;Xdot is not installed. Display is set to off.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif mode is &#39;file&#39;:
            self.attr[&#39;display&#39;] = &#39;file&#39;
        elif mode is &#39;matplotlib&#39;:
            self.attr[&#39;display&#39;] = &#39;matplotlib&#39;
        else:
            raise Exception(&#39;%s is not a valid display mode.&#39; %mode)

    def display(self, item = &#39;all&#39;, basename = &#39;graph&#39;, format=&#39;png&#39;,
                count=None, pause=False, wait_for_click=True):
        &#39;&#39;&#39;
        Displays/Saves images requested. BranchAndBound method calls this method
        to visualize the branch and bound tree.
        &#39;&#39;&#39;
        if self.attr[&#39;layout&#39;] != &#39;bak&#39;:
            if &#39;init_log_cond&#39; in self.root.attr:
                max_log_cond = 0
                for n in list(self.nodes.values()):
                    if &#39;init_log_cond&#39; in n.attr:
                        max_log_cond = max(n.attr[&#39;init_log_cond&#39;], max_log_cond)
                for n in list(self.nodes.values()):
                    if &#39;init_log_cond&#39; in n.attr:
                        log_begin = n.attr[&#39;init_log_cond&#39;]
                        log_end = n.attr[&#39;final_log_cond&#39;]
                        normalized_cond = (1-old_div(log_begin,max_log_cond))
                        color = str(hex(int(normalized_cond*256))[2:]) if normalized_cond &gt;= .0625 else &#39;0&#39; + str(hex(int(normalized_cond*256))[2:])
                        n.attr[&#39;label&#39;] = &#39;%.0f \n %.0f&#39; % (log_begin, log_end)
                        n.attr[&#39;color&#39;] = &#39;#&#39; + color*3
                        n.attr[&#39;fillcolor&#39;] = &#39;#&#39; + color*3
                        n.attr[&#39;style&#39;] = &#39;filled&#39;
                    else:
                        n.attr[&#39;label&#39;] = &#39; &#39;
            BinaryTree.display(self, pause = pause, wait_for_click = wait_for_click)
            return
        if self.attr[&#39;display&#39;] is &#39;off&#39;:
            return
        if self.attr[&#39;display&#39;] is &#39;matplotlib&#39;:
            gnuplot_script = None
            if item==&#39;all&#39;:
                self.display_all()
            elif item==&#39;tree&#39;:
                gnuplot_script = self.GenerateTreeImage()
            elif item==&#39;scatterplot&#39;:
                gnuplot_script = self.GenerateScatterplot()
            elif item==&#39;histogram&#39;:
                gnuplot_script = self.GenerateHistogram()
            elif item==&#39;incumbent&#39;:
                gnuplot_script = self.GenerateIncumbentPath()
            elif item==&#39;forecast&#39;:
                gnuplot_script = self.GenerateForecastImages()
            else:
                raise Exception(&#39;Unknown display() method argument %s&#39; %item)
            if gnuplot_script is not None:
                self.display_image(gnuplot_script)
            # clean auxilary files.
            histogram_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;histogram&#34;)]
            incumbent_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;incumbentpath&#34;)]
            scatterplot_files = [f for f in os.listdir(&#34;.&#34;)
                                 if f.startswith(&#34;scatterplot&#34;)]
            t_fathomed_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_fathomed&#34;)]
            t_infeasible_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_infeasible&#34;)]
            t_pregnant_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_pregnant&#34;)]
            t_integer_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;tree_integer&#34;)]
            t_branched_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;tree_branched&#34;)]
            bak_filelist = (histogram_files + incumbent_files +
                            scatterplot_files + t_fathomed_files +
                            t_integer_files + t_branched_files +
                            t_infeasible_files + t_pregnant_files)
            for f in bak_filelist:
                os.remove(f)
        elif self.attr[&#39;display&#39;] is &#39;xdot&#39;:
            if XDOT_INSTALLED:
                window = xdot.DotWindow()
                window.set_dotcode(self.to_string())
                window.connect(&#39;destroy&#39;, gtk.main_quit)
                gtk.main()
            else:
                print(&#39;Error: xdot not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif self.attr[&#39;display&#39;] is &#39;file&#39;:
            if count is not None:
                basename = basename + &#39;_&#39; + str(count)
            if self.attr[&#39;layout&#39;] is &#39;dot2tex&#39;:
                if DOT2TEX_INSTALLED:
                    if format != &#39;pdf&#39; or format != &#39;ps&#39;:
                        print(&#34;Dot2tex only supports pdf and ps formats,&#34;+\
                            &#34;falling back to pdf&#34;)
                        format = &#39;pdf&#39;
                    self.set_layout(&#39;dot&#39;)
                    tex = dot2tex.dot2tex(self.to_string(), autosize=True,
                                          texmode = &#39;math&#39;,
                                          template = DOT2TEX_TEMPLATE)
                    f = open(basename+&#39;.tex&#39;, &#39;w&#39;)
                    f.write(tex)
                    f.close()
                    subprocess.call([&#39;latex&#39;, basename])
                    if format == &#39;ps&#39;:
                        subprocess.call([&#39;dvips&#39;, basename])
                    elif format == &#39;pdf&#39;:
                        subprocess.call([&#39;pdflatex&#39;, basename])
                    self.set_layout(&#39;dot2tex&#39;)
                    # clean auxilary files.
                    aux_filelist = [basename+&#39;.tex&#39;, basename+&#39;.log&#39;,
                                    basename+&#39;.dvi&#39;, basename+&#39;.aux&#39;]
                    for f in aux_filelist:
                        os.remove(f)
                else:
                    print(&#34;Dot2tex not installed, falling back to graphviz&#34;)
                    self.set_layout(&#39;dot&#39;)
                    self.write(basename+&#39;.&#39;+format, self.get_layout(), format)
            else:
                gnuplot_script = None
                if item==&#39;all&#39;:
                    self.display_all()
                elif item==&#39;tree&#39;:
                    gnuplot_script = self.GenerateTreeImage()
                elif item==&#39;scatterplot&#39;:
                    gnuplot_script = self.GenerateScatterplot()
                elif item==&#39;histogram&#39;:
                    gnuplot_script = self.GenerateHistogram()
                elif item==&#39;incumbent&#39;:
                    gnuplot_script = self.GenerateIncumbentPath()
                elif item==&#39;forecast&#39;:
                    gnuplot_script = self.GenerateForecastImages()
                else:
                    raise Exception(&#39;Unknown display() method argument %s&#39; %item)
                if gnuplot_script is not None:
                    self.write_image(gnuplot_script, basename+&#39;.&#39;+format)
                # clean auxilary files.
                histogram_files = [f for f in os.listdir(&#34;.&#34;)
                                   if f.startswith(&#34;histogram&#34;)]
                incumbent_files = [f for f in os.listdir(&#34;.&#34;)
                                   if f.startswith(&#34;incumbentpath&#34;)]
                scatterplot_files = [f for f in os.listdir(&#34;.&#34;)
                                     if f.startswith(&#34;scatterplot&#34;)]
                t_fathomed_files = [f for f in os.listdir(&#34;.&#34;)
                                    if f.startswith(&#34;tree_fathomed&#34;)]
                t_infeasible_files = [f for f in os.listdir(&#34;.&#34;)
                                      if f.startswith(&#34;tree_infeasible&#34;)]
                t_pregnant_files = [f for f in os.listdir(&#34;.&#34;)
                                    if f.startswith(&#34;tree_pregnant&#34;)]
                t_integer_files = [f for f in os.listdir(&#34;.&#34;)
                                   if f.startswith(&#34;tree_integer&#34;)]
                t_branched_files = [f for f in os.listdir(&#34;.&#34;)
                                    if f.startswith(&#34;tree_branched&#34;)]
                bak_filelist = (histogram_files + incumbent_files +
                                scatterplot_files + t_fathomed_files +
                                t_integer_files + t_branched_files +
                                t_infeasible_files + t_pregnant_files)
                for f in bak_filelist:
                    os.remove(f)
        else:
            raise Exception(&#39;Unknown display mode %s&#39; %self.attr[&#39;display&#39;])

    def display_all(self):
        &#39;&#39;&#39;
        Assumes all the images have the same size.
        &#39;&#39;&#39;
        print (&#39;This function is deprected and no longer functions&#39;)
        return

        # Old source, just in case
        # if not (MATPLOTLIB_INSTALLED and PIL_INSTALLED:
        #     print(&#39;Matplotlib or Pillow not installed. Display disabled&#39;)
        #     return
        # tree = self.GenerateTreeImage()
        # scatterplot = self.GenerateScatterplot()
        # histogram = self.GenerateHistogram()
        # incumbent = self.GenerateIncumbentPath()
        # if tree is not None:
        #     imTree = StringIO(tree)
        #     pTree = pygame.image.load(imTree, &#39;png&#39;)
        #     sTree = pTree.get_size()
        #     rTree = pygame.Rect(0,0,sTree[0],sTree[1])
        # if scatterplot is not None:
        #     imScatterplot = StringIO(scatterplot)
        #     pScatterplot = pygame.image.load(imScatterplot, &#39;png&#39;)
        #     sScatterplot = pScatterplot.get_size()
        #     rScatterplot = pygame.Rect(sTree[0],0,sScatterplot[0],
        #                                sScatterplot[1])
        # if histogram is not None:
        #     imHistogram = StringIO(histogram)
        #     pHistogram = pygame.image.load(imHistogram, &#39;png&#39;)
        #     sHistogram = pHistogram.get_size()
        #     rHistogram = pygame.Rect(0,sTree[1],sHistogram[0],sHistogram[1])
        # if incumbent is not None:
        #     imIncumbent = StringIO(incumbent)
        #     pIncumbent = pygame.image.load(imIncumbent, &#39;png&#39;)
        #     sIncumbent = pIncumbent.get_size()
        #     rIncumbent = pygame.Rect(sTree[0],sTree[1],sIncumbent[0],
        #                              sIncumbent[1])
        # screen = pygame.display.set_mode((sTree[0]+sTree[0], sTree[1]+sTree[1]))
        # if tree is not None:
        #     screen.blit(pTree, rTree)
        # if scatterplot is not None:
        #     screen.blit(pScatterplot, rScatterplot)
        # if histogram is not None:
        #     screen.blit(pHistogram, rHistogram)
        # if incumbent is not None:
        #     screen.blit(pIncumbent, rIncumbent)
        # pygame.display.flip()
        # if self._wait_for_keypress:
        #     pause = True
        #     print(&#34;Press any key to continue to next image (ESCAPE to disable pausing)&#34;)
        # else:
        #     pause = False
        # while pause:
        #     e = pygame.event.poll()
        #     if e.type == pygame.KEYDOWN:
        #         keystate = pygame.key.get_pressed()
        #         if keystate[pygame.K_ESCAPE] != 0:
        #             self._wait_for_keypress = False
        #         break
        #     if e.type == pygame.QUIT:
        #         pause = False
        #         pygame.display.quit()
        #         # sys.exit() exits the whole program and I (aykut) guess it is
        #         # not appropriate here.
        #         #sys.exit()

    def write_image(self, gnuplot_script, filename):
        if not (MATPLOTLIB_INSTALLED and PIL_INSTALLED):
            print(&#39;Either matplotlib or Pillow is not installed. Display disabled&#39;)
            return
        try:
            p = subprocess.run([&#39;gnuplot&#39;], capture_output = True,
                               input = bytearray(gnuplot_script, &#39;utf8&#39;))
        except OSError:
            print(&#39;&#39;&#39;Gnuplot executable not found.
Gnuplot must be installed and in your search path.
After installation, ensure that the PATH variable is properly set.&#39;&#39;&#39;)
            return
        p.check_returncode()

        if p.stderr:
            print(p.stderr)        

        if isinstance(filename, str):
            with open(filename, &#34;w+b&#34;) as f:
                f.write(p.stdout)
        else:
            filename.write(p.stdout)

    def display_image(self, gnuplot_script, pause = False, wait_for_click = True):

        if not (PIL_INSTALLED and MATPLOTLIB_INSTALLED):
            print(&#39;Warning: Either matplotlib or Pillow is not installed. Cannot display.&#39;)
            return
        
        tmp_fd, tmp_name = tempfile.mkstemp()
        tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
        self.write_image(gnuplot_script, tmp_file)
        tmp_file.close()
        im = PIL_Image.open(tmp_name)
        plt.figure(1)
        plt.clf()
        plt.axis(&#39;off&#39;)
        plt.imshow(im, interpolation=&#39;bilinear&#39; #resample=True
                   #extent = (0, 100, 0, 100)
        )
        if wait_for_click == True:
            plt.draw()
            try:
                if plt.waitforbuttonpress(timeout = 10000):
                    plt.close()
                    exit()
            except:
                exit()
        else:
            plt.show(block=pause)
        im.close()

    def set_label(self, label):
        self._label = label

    def set_logscaley(self, boolean):
        self._logscaley = boolean

    def set_fathom(self, boolean):
        self._fathom = boolean

    def set_edge_limit(self, limit):
        self._edge_limit = limit

    def set_sample_tree(self, number):
        self._sample_tree = number

    def AddOrUpdateNode(self, id, parent_id, branch_direction, status, lp_bound,
                        integer_infeasibility_count, integer_infeasibility_sum,
                        condition_begin = None, condition_end = None,
                        **attrs):
        &#39;&#39;&#39;
        This method designed to update nodes (in BAK) but we use it for
        updating/adding arcs. This is because of the tree data structure the
        authors adopted in BAK.
        We can divide these attributes such that some will belong to the edge
        parent_id-&gt;id and the others belong to the id node. The following shows
        whether the attribute belongs to edge or node.
        branch direction -&gt; edge
        status -&gt; node
        lp_bound -&gt; node
        integer_infeasibility_count -&gt; node
        integer_infeasibility_sum -&gt; node
        parent_id -&gt; node
        &#39;&#39;&#39;
        if (condition_begin is not None) and (condition_end is not None):
            #Figure out the color
            attrs[&#39;init_log_cond&#39;] = math.log(condition_begin, 10)
            attrs[&#39;final_log_cond&#39;] = math.log(condition_end, 10)
        if id in self.neighbors:
            # node already exists, update attributes
            self.set_node_attr(id, &#39;status&#39;, status)
            self.set_node_attr(id, &#39;lp_bound&#39;, lp_bound)
            self.set_node_attr(id, &#39;integer_infeasibility_count&#39;,
                               integer_infeasibility_count)
            self.set_node_attr(id, &#39;integer_infeasibility_sum&#39;,
                               integer_infeasibility_sum)
            if (condition_begin is not None) and (condition_end is not None):
                self.set_node_attr(id, &#39;init_log_cond&#39;,
                                   math.log(condition_begin, 10))
                self.set_node_attr(id, &#39;final_log_cond&#39;,
                                   math.log(condition_end, 10))
        elif self.root is None:
            self.add_root(id, status = status, lp_bound = lp_bound,
                          integer_infeasibility_count = integer_infeasibility_count,
                          integer_infeasibility_sum = integer_infeasibility_sum,
                          subtree_root = None, **attrs)
        elif parent_id is not None:
            if branch_direction == &#39;L&#39;:
                self.add_left_child(id, parent_id, status = status,
                    lp_bound = lp_bound,
                    integer_infeasibility_count = integer_infeasibility_count,
                    integer_infeasibility_sum = integer_infeasibility_sum,
                    subtree_root = None, **attrs)
            elif branch_direction == &#39;R&#39;:
                self.add_right_child(id, parent_id, status = status,
                    lp_bound = lp_bound,
                    integer_infeasibility_count = integer_infeasibility_count,
                    integer_infeasibility_sum = integer_infeasibility_sum,
                    subtree_root = None, **attrs)
        else:
            print(&#39;this should not happen.&#39;)
            raise Exception()
        if lp_bound is not None:
            self.UpdateObjectiveValueLimits(lp_bound)
            # Set optimization sense if not yet set
            if self._optimization_sense is None:
                if lp_bound &lt; self.root.get_attr(&#39;lp_bound&#39;):
                    self._optimization_sense = &#39;max&#39;
                elif lp_bound &gt; self.root.get_attr(&#39;lp_bound&#39;):
                    self._optimization_sense = &#39;min&#39;
            if self._optimization_sense == &#39;min&#39; and lp_bound &lt; self.root.get_attr(&#39;lp_bound&#39;):
                print(&#34;Switching guess about objective sense to maximization based on bound change&#34;)
                self._optimization_sense = &#39;max&#39;
            if self._optimization_sense == &#39;max&#39; and lp_bound &gt; self.root.get_attr(&#39;lp_bound&#39;):
                print(&#34;Switching guess about objective sense to minimization based on bound change&#34;)
                self._optimization_sense = &#39;max&#39;
        if integer_infeasibility_sum is not None:
            if (self._max_integer_infeasibility_sum is None or
                integer_infeasibility_sum &gt;
                self._max_integer_infeasibility_sum):
                self._max_integer_infeasibility_sum = integer_infeasibility_sum

    def IsBetterThan(self, value1, value2):
        &#34;&#34;&#34;
        Returns True if value1 is better than value2 as an objective value.
        This depends on the optimization sense of the instance.
        Args:
          value1: Float.
          value2: Float.
        Returns:
          True if value1 is better than value2 as an objective value.
        &#34;&#34;&#34;
        if self._optimization_sense is None:
            print(&#34;Optimization sense is not set, assuming sense is miniminzation&#34;)
            self._optimization_sense = &#39;min&#39;
        if self._optimization_sense == &#39;min&#39;:
            return value1 &lt; value2
        else:
            return value1 &gt; value2

    def IsBetterThanIncumbent(self, value):
        &#34;&#34;&#34;
        Returns True if the passed value is better than current incumbent.
        Args:
          value: Float to use for comparison.
        Returns:
          True if the passed value is better than the current incumbent.
          &#39;Better&#39; is determined by the sense of optimization.
        &#34;&#34;&#34;
        if self._incumbent_value is None:
            return True
        else:
            return self.IsBetterThan(value, self._incumbent_value)

    def UpdateObjectiveValueLimits(self, value):
        &#34;&#34;&#34;Updates the min and max objective values if appropriate.
        Args:
          value: Float objective value.
        &#34;&#34;&#34;
        if self._max_objective_value is None:
            self._max_objective_value = value
            self._min_objective_value = value
        else:
            if value &gt; self._max_objective_value:
                self._max_objective_value = value
            if value &lt; self._min_objective_value:
                self._min_objective_value = value

    def AddProgressMeasures(self):
        # No progress measures if there is no incumbent yet
        if self._incumbent_value is None:
            return
        # Store sum-of-subtree-gaps
        # We need to traverse all nodes unfortunately
        # TODO(bhunsaker): check whether we can just traverse active nodes
        active_node_count = 0
        subtree_bounds = {}
        new_integer_ssg = 0  # Only needed if this is a new integer solution
        for node_id in self.get_node_list():
            status = self.get_node_attr(node_id, &#39;status&#39;)
            if status == &#39;candidate&#39; or status == &#39;pregnant&#39;:
                lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
                subtree_root = self.get_node_attr(node_id, &#39;subtree_root&#39;)
                # Optional check for fathomed nodes.
                if (self._fathom and
                    not self.IsBetterThanIncumbent(lp_bound)):
                    continue
                active_node_count += 1
                if (subtree_root not in subtree_bounds or
                    self.IsBetterThan(lp_bound, subtree_bounds[subtree_root])):
                    subtree_bounds[subtree_root] = lp_bound
                if self._new_integer_solution:
                    self.set_node_attr(node_id, &#39;subtree_root&#39;, id)
                    new_integer_ssg += abs(self._incumbent_value - lp_bound)
        # If we have a new integer solution, we need to compute what
        # the measure would be with the previous integer solution for
        # scaling purposes.
        if (self._new_integer_solution and
            self._previous_incumbent_value is not None):
            reference_value = self._previous_incumbent_value
        else:
            reference_value = self._incumbent_value
        sum_subtree_gaps = 0
        for lp_bound in list(subtree_bounds.values()):
            sum_subtree_gaps += abs(reference_value - lp_bound)
        # Start a new sequence if a new integer solution was just found
        if self._new_integer_solution:
            if new_integer_ssg &gt;= 1e-6:
                scale_factor = (old_div(float(sum_subtree_gaps),
                                float(new_integer_ssg)))
            else:
                scale_factor = 1.0
            self._sum_subtree_gaps_forecaster.StartNewSequence(scale_factor)
            # sum_subtree_gaps was based on the previous integer solution;
            # update it now
            sum_subtree_gaps = new_integer_ssg
        self._sum_subtree_gaps_forecaster.AddMeasure(self._time,
                                                     sum_subtree_gaps,
                                                     active_node_count,
                                                     len(self.get_node_list()))
        # Add objective gap measure.  Note that this relies on the
        # active_node_count computed above.
        if self._new_integer_solution:
            self._objective_gap_forecaster.StartNewSequence(1.0)
        if self._optimization_sense == &#39;min&#39;:
            obj_gap = self._incumbent_value - self._min_objective_value
        else:
            obj_gap = self._max_objective_value - self._incumbent_value
        self._objective_gap_forecaster.AddMeasure(self._time, obj_gap,
                                                  active_node_count,
                                                  len(self.get_node_list()))

    def GetImageCounterString(self):
        &#34;&#34;&#34;
        Returns a string with the image counter.
        &#34;&#34;&#34;
        return &#39;%03d&#39; % self._image_counter

    def WriteHistogramScript(self, num_bins, bin_width, max_bin_count,
                                 lp_bound, data_filename, output_file):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate a histogram image.
        Args:
          num_bins: Integer number of bins for the histogram.
          bin_width: Float width of the bins in terms of objective values.
          max_bin_count: Integer number of the highest bin count.
          lp_bound: Float value of the current LP bound.
          data_filename: String name of the file; used for display purposes.
        &#34;&#34;&#34;
        # TODO(bhunsaker): add checks for bin_width zero
        if self._incumbent_value is not None:
            incumbent_bin = 1 + ((self._incumbent_value -
                                  self._histogram_lower_bound) // bin_width)
            incumbent_x_coord = 0.5 + (old_div((self._incumbent_value -
                                        self._histogram_lower_bound),
                                       bin_width))
        lp_bound_bin = 1 + ((lp_bound - self._histogram_lower_bound) //
                            bin_width)
        lp_bound_x_coord = 0.5 + (old_div((lp_bound - self._histogram_lower_bound),
                                  bin_width))
        # TODO(bhunsaker): Ask Osman about adjust_xcoord option, which appears
        #    to put the vertical lines at the edge of bins rather than the
        #    true location.
        # Output the Gnuplot script to a file.
        script = &#34;&#34;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the scatter plot.
        index_string = self.GetImageCounterString()
        output_filename = &#34;histogram.&#34;+index_string+&#34;.png&#34;
        if output_file:
            script += &#39;set output &#34;%s&#34;\n&#39; % output_filename
        if self._filename is None:
            script += &#39;set title &#34;Histogram of LP Bounds&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Histogram of LP Bounds: %s, %s, %.2fs&#34;\n&#39;
                       % (self._filename, self._label, self._time))
        script += &#39;set xlabel &#34;obj. value&#34;\n&#39;
        script += &#39;set ylabel &#34;number of nodes&#34;\n&#39;
        if self._logscaley:
            script += &#39;set logscale y\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set tics scale 0.001\n&#39;

        script += &#39;set xrange [0:%d+1]\n&#39; % num_bins
        if self._logscaley:
            script += &#39;set yrange [1:%d*1.2]\n&#39; % max_bin_count
        else:
            script += &#39;set yrange [0:%d*1.2]\n&#39; % max_bin_count
        script += &#39;set xtics rotate by 90\n&#39;
        # Mark tics for each bin.
        script += &#39;set xtics (&#39;
        # TODO(bhunsaker): Consider putting this in a loop.
        x_values = [&#39;&#34;%0.2f&#34; %0.2f&#39; %
                    (self._histogram_lower_bound + i * bin_width, i + 0.5)
                    for i in range(num_bins + 1)]
        script += &#39;, &#39;.join(x_values) + &#39;)\n&#39;
        # Plot LP bound and incumbent tics.
        script += &#39;set x2tics (&#39;
        script += &#39;&#34;%0.2f&#34; %d&#39; % (lp_bound, lp_bound_bin)
        if self._incumbent_value is not None:
            script += &#39;, &#34;%0.2f&#34;%d)\n&#39; % (self._incumbent_value,
                                                  incumbent_bin)
        else:
            script += &#39;)\n&#39;
        plot_parts = []
        # Plot the data points.
        plot_parts.append(&#39;\&#39;%s\&#39; with boxes fill solid 0.2&#39; % data_filename)
        # Draw the vertical lp_bound and incumbent lines.
        script += &#39;set parametric\n&#39;
        script += &#39;set trange [0:%d*1.5]\n&#39; % max_bin_count
        plot_parts.append(&#39;%0.2f,t linetype 2&#39; % lp_bound_x_coord)
        if self._incumbent_value is not None:
            plot_parts.append(&#39;%0.2f,t linetype 5&#39; % incumbent_x_coord)
        script += &#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts)
        script += &#39;unset parametric\n&#39;
        script += &#39;show output\n&#39;
        return script

    def AdjustHistogramEndBins(self, objective_list, num_bins, bin_width,
                               bin_counts, bin_centers, bin_widths):
        &#34;&#34;&#34;
        Adjusts the two end bins if necessary to make them narrower.
        The two end bins may need to be narrower than the other bins so that
        they do not go past the current incumbent value on one end and the
        current lp bound on the other.  So that the histogram is still correct
        in areas, the height of these bins needs to be adjusted so that the
        area does not change.

        Note that there is likely to be some bias toward taller bins on
        the ends since they always have a point at one end of their width.  It
        may be more accurate visually to ignore or discount that one point when
        determining the bin height, but that is not currently done.

        Args:
          objective_list: List of float objective values.
          num_bins: Integer number of bins.
          bin_width: Float standard width of bins in terms of objective values.
          bin_counts: List of integer counts for each bin.
          bin_centers: List of float coordinates for the center of each bin.
          bin_widths: List of float widths for bins, allowing for individualized
            widths.
        &#34;&#34;&#34;
        if self._optimization_sense == &#39;min&#39;:
            lp_bound = min(objective_list)
            lower_bound = lp_bound
            if self._incumbent_value is not None:
                upper_bound = self._incumbent_value
            else:
                upper_bound = self._histogram_upper_bound
        else:
            lp_bound = max(objective_list)
            upper_bound = lp_bound
            if self._incumbent_value is not None:
                lower_bound = self._incumbent_value
            else:
                lower_bound = self._histogram_lower_bound
        # The end bins may have unusual centers and widths
        highest_nonempty_bin = int((upper_bound -
                                    self._histogram_lower_bound) // bin_width)
        if (highest_nonempty_bin &lt; num_bins and
            bin_counts[highest_nonempty_bin] &gt; 0):
            highest_x_coord = 0.5 + (old_div((upper_bound -
                                      self._histogram_lower_bound), bin_width))
            highest_nonempty_bin_width, unused_int = math.modf(0.5 +
                                                               highest_x_coord)
            if highest_nonempty_bin_width == 0.0:
                highest_nonempty_bin_width = 1.0
            bin_widths[highest_nonempty_bin] = highest_nonempty_bin_width
            bin_centers[highest_nonempty_bin] = highest_x_coord - (
                old_div(highest_nonempty_bin_width, 2))
            # Scale the height appropriately
            bin_counts[highest_nonempty_bin] /= bin_widths[highest_nonempty_bin]
        lowest_nonempty_bin = int((lower_bound -
                                   self._histogram_lower_bound) // bin_width)
        if bin_counts[lowest_nonempty_bin] &gt; 0:
            lowest_x_coord = 0.5 + (old_div((lower_bound -
                                     self._histogram_lower_bound), bin_width))
            lowest_nonempty_bin_excess, unused_int = math.modf(0.5 +
                                                               lowest_x_coord)
            bin_widths[lowest_nonempty_bin] = 1.0 - lowest_nonempty_bin_excess
            bin_centers[lowest_nonempty_bin] = (
                lowest_x_coord + old_div(bin_widths[lowest_nonempty_bin], 2))
            # Scale the height appropriately
            bin_counts[lowest_nonempty_bin] /= bin_widths[lowest_nonempty_bin]

    def GenerateHistogram(self, output_file = False):
        &#34;&#34;&#34;
        Generate files necessary for a histogram image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        Args:
          time: Float number of seconds since the start of optimization.
        &#34;&#34;&#34;
        num_bins = 20
        # Compute the bin width and counts.
        objective_list = []
        for n in self.get_node_list():
            if (self.get_node_attr(n,&#39;status&#39;) == &#39;candidate&#39; or
                self.get_node_attr(n,&#39;status&#39;) == &#39;pregnant&#39;):
                lp_bound = self.get_node_attr(n,&#39;lp_bound&#39;)
                if not self.IsBetterThanIncumbent(lp_bound):
                    continue
                objective_list.append(lp_bound)
        # TODO(aykut) added the following check, we need it since we generate
        # histograms real time
        # we can not generate histogram if we do not have upperl and lower
        #bounds
        if len(objective_list)==0 or self._incumbent_value is None:
            return None
        # The first time we create a histogram, set bounds for objective
        # values.
        # TODO(bhunsaker): Consider bounds; talk to Osman.
        if self._histogram_lower_bound is None:
            if self._optimization_sense == &#39;min&#39;:
                self._histogram_lower_bound = min(objective_list)
                if self._incumbent_value is not None:
                    self._histogram_upper_bound = self._incumbent_value
                else:
                    self._histogram_upper_bound = max(objective_list)
            else:
                self._histogram_upper_bound = max(objective_list)
                if self._incumbent_value is not None:
                    self._histogram_lower_bound = self._incumbent_value
                else:
                    self._histogram_lower_bound = min(objective_list)
        bin_width = old_div((self._histogram_upper_bound -
                     self._histogram_lower_bound), float(num_bins))
        bin_counts = [0.0 for i in range(num_bins)]
        for value in objective_list:
            bin = int(math.floor(old_div((value - self._histogram_lower_bound),
                                 bin_width)))
            # Special case for the largest value.
            if (value &gt;= self._histogram_upper_bound and
                value &lt; self._histogram_upper_bound + 1e-6):
                bin = num_bins - 1
            if bin &lt; 0:
                return
            assert bin &lt; num_bins, &#39;%d (%f) !&lt; %d (%f)&#39; % (
                bin, value, num_bins, self._histogram_upper_bound)
            bin_counts[bin] += 1
        max_bin_count = max(bin_counts)
        bin_centers = [i + 1.0 for i in range(len(bin_counts))]
        bin_widths = [1.0 for i in range(len(bin_counts))]
        self.AdjustHistogramEndBins(objective_list, num_bins, bin_width,
                                    bin_counts, bin_centers, bin_widths)
        if self._optimization_sense == &#39;min&#39;:
            lp_bound = min(objective_list)
        else:
            lp_bound = max(objective_list)
        # Output the bin data to a file.
        index_string = self.GetImageCounterString()
        data_filename = &#39;histogram%s.dat&#39; % index_string
        data_file = open(data_filename, &#39;w&#39;)
        for index in range(len(bin_counts)):
            data_file.write(&#39;%f %f %f\n&#39; % (bin_centers[index],
                                            bin_counts[index],
                                            bin_widths[index]))
        data_file.close()
        histogram_script = self.WriteHistogramScript(num_bins, bin_width,
                           max_bin_count, lp_bound, data_filename, output_file)
        # TODO(bhunsaker): Temporary hack
        #   This allows the bounds to be reset until an incumbent is found.
        if self._incumbent_value is None:
            self._histogram_lower_bound = None
            self._histogram_upper_bound = None
        return histogram_script

    def GetImageObjectiveBounds(self, min_value, max_value):
        &#34;&#34;&#34;
        Return min and max bounds to be used for images.
        Images should use bounds that are slightly wider than observed
        objective values.  Also, the special case of a single value must be
        handled.
        Args:
          min_value: Float minimum objective value.
          max_value: Float maximum objective value.
        Returns:
          A tuple of two float values (lower_bound, upper_bound).
        &#34;&#34;&#34;
        obj_range = max_value - min_value
        if obj_range &gt; 0:
            image_max_obj = max_value + 0.01 * obj_range
            image_min_obj = min_value - 0.01 * obj_range
        else:
            if max_value &gt;= 0:
                image_max_obj = 1.01 * max_value
            else:
                image_max_obj = 0.99 * max_value
            if min_value &gt;= 0:
                image_min_obj = 0.99 * min_value
            else:
                image_min_obj = 1.01 * min_value
        return (image_min_obj, image_max_obj)

    def WriteScatterplotScript(self, data_filename, output_file):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate a scatterplot image.
        Args:
          data_filename: String name of the file; used for display purposes.
        &#34;&#34;&#34;
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._scatterplot_lower_bound, self._scatterplot_upper_bound)
        index_string = self.GetImageCounterString()
        output_filename = &#34;scatterplot.&#34;+index_string+&#34;.png&#34;
        script = &#34;&#34;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the scatter plot.
        if output_file:
            script += &#39;set output &#34;%s&#34;\n&#39; % output_filename
        if self._filename is None:
            script += &#39;set title &#34;Scatterplot&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Scatterplot: %s, %s, %ds&#34;\n&#39; % (
                    self._filename, self._label, int(self._time)))
        script += &#39;set pointsize 0.8\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
        script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
        script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                          self._max_integer_infeasibility_sum)
        script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                          image_max_obj))
        plot_parts = []
        # Plot the data points.
        plot_parts.append(&#39;\&#39;%s\&#39; with points pointtype 2 linetype 1&#39; %
                          data_filename)
        # Also plot the incumbent line.
        if self._incumbent_value is not None:
            plot_parts.append(&#39;%0.6f linetype 2 linewidth 0.5&#39; %
                              self._incumbent_value)
        # Plot the incumbent&#39;s parent if it&#39;s available.
        if self._incumbent_parent is not None:
            #incumbent_parent = self.get_node(self._incumbent_parent)
            plot_parts.append(&#39;&#34;&lt; echo %0.6f %0.6f&#34; &#39;
                              &#39;with points pointtype 9 pointsize 1.2&#39; %
                              (self.get_node_attr(self._incumbent_parent,
                                                  &#39;integer_infeasibility_sum&#39;),
                               self.get_node_attr(self._incumbent_parent,
                                                  &#39;lp_bound&#39;)))
        script += &#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts)
        script += &#39;show output\n&#39;
        return script

    def GenerateScatterplot(self, output_file = False):
        &#34;&#34;&#34;
        Generate files necessary for a scatterplot image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        Args:
            output_file: if not given the gnuplot image will not be written
        to disk but returned (to be displayed in matplotlib window)
        &#34;&#34;&#34;
        # Output data points.
        index_string = self.GetImageCounterString()
        data_filename = &#39;scatterplot%s.dat&#39; % index_string
        data_file = open(data_filename, &#39;w&#39;)
        if self._scatterplot_lower_bound is None:
            bounds = []
        # Write objective values and integer infeasibility sum information
        # for candidate and pregnant nodes.
        for node in self.get_node_list():
            status = self.get_node_attr(node, &#39;status&#39;)
            lp_bound = self.get_node_attr(node,&#39;lp_bound&#39;)
            if status == &#39;candidate&#39; or status == &#39;pregnant&#39;:
                # Optional check for fathomed nodes.
                if (self._fathom and
                    not self.IsBetterThanIncumbent(lp_bound)):
                    continue
                data_file.write(&#39;%0.6f %0.6f\n&#39; % (
                        self.get_node_attr(node, &#39;integer_infeasibility_sum&#39;),
                        lp_bound))
                # Set the image objective bounds the first image.
                if self._scatterplot_lower_bound is None:
                    bounds.append(lp_bound)
        data_file.close()
        if self._scatterplot_lower_bound is None:
            if len(bounds) &lt;= 1:
                return None
            self._scatterplot_lower_bound = min(bounds)
            self._scatterplot_upper_bound = max(bounds)
            # The incumbent overrides a bound if present.
            if self._incumbent_value is not None:
                if self._optimization_sense == &#39;min&#39;:
                    self._scatterplot_upper_bound = self._incumbent_value
                else:
                    self._scatterplot_lower_bound = self._incumbent_value
        scatterplot_script = self.WriteScatterplotScript(data_filename,
                                                         output_file)
        return scatterplot_script

    def WriteIncumbentPathScript(self, data_filename):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate an incumbent path image.
        Args:
          data_filename: String name of the file; used for display purposes.
        &#34;&#34;&#34;
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._scatterplot_lower_bound, self._scatterplot_upper_bound)
        script = &#39;&#39;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;
        if self._filename is None:
            script += &#39;set title &#34;Incumbent path&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Incumbent path (%s %.2fs %s)&#34;\n&#39; % (
                    self._filename, self._time, self._label))
        script += &#39;set pointsize 0.8\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
        script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
        script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                          self._max_integer_infeasibility_sum)
        script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                          image_max_obj))
        # Plot the data points and connecting lines.
        script += (&#39;plot \&#39;%s\&#39; with points pointtype 2, &#39;
                          &#39;\&#39;%s\&#39; with lines linetype 2\n&#39; %
                          (data_filename, data_filename))
        script += &#39;show output\n&#39;
        return script

    def WriteAllIncumbentPathsScript(self):
        &#34;&#34;&#34;
        Return a Gnuplot script string to generate an incumbent path image.
        Args:
          data_filenames: List of string names of files.
        &#34;&#34;&#34;
        data_filenames = self._incumbent_path_datafiles
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._scatterplot_lower_bound, self._scatterplot_upper_bound)
        script = &#39;&#39;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;

        # Make settings for the scatter plot.
        if self._filename is None:
            script += &#39;set title &#34;Incumbent paths&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Incumbent paths (%s %.2fs %s)&#34;\n&#39; % (
                    self._filename, self._time, self._label))
        script += &#39;set pointsize 0.8\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
        script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
        script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                          self._max_integer_infeasibility_sum)
        script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                          image_max_obj))
        # Plot the data points and connecting lines.
        command_list = []
        for filename in data_filenames:
            command_list.append(&#39;\&#39;%s\&#39; with points pointtype 2, &#39;
                                &#39;\&#39;%s\&#39; with lines linetype 2&#39; %
                                (filename, filename))
        script += &#39;plot %s\n&#39; % &#39;,&#39;.join(command_list)
        script += &#39;show output\n&#39;
        return script

    def GenerateIncumbentPath(self):
        &#34;&#34;&#34;
        Generate files necessary for an incumbent scatterplot path image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        &#34;&#34;&#34;
        if self._incumbent_parent is None:
            return
        if self._scatterplot_lower_bound is None:
            return
        if self._scatterplot_upper_bound is None:
            return
        index_string = self.GetImageCounterString()
        # Output data points.
        data_filename = &#39;incumbentpath%s.dat&#39; % index_string
        data_file = open(data_filename, &#39;w&#39;)
        # Write objective values and integer infeasibility sum information
        # for ancestor nodes.
        data_file.write(&#39;0 %0.6f\n&#39; % self._incumbent_value)
        parent = self._incumbent_parent
        # TODO(bhunsaker): I think the following assumes a unique value for the
        #   parent of the root.
        while parent != None:
            data_file.write(&#39;%0.6f %0.6f\n&#39;
                            % (self.get_node_attr(parent,
                               &#39;integer_infeasibility_sum&#39;),
                             self.get_node_attr(parent, &#39;lp_bound&#39;)))
            parent = self.get_node_attr(parent, &#39;parent&#39;)
        data_file.close()
        self._incumbent_path_datafiles.append(data_filename)
        # Output the Gnuplot script to a file.
        path_script = self.WriteIncumbentPathScript(data_filename)
        return path_script

    def GenerateAllIncumbentPaths(self):
        &#34;&#34;&#34;
        Generate file for a path image with all incumbent paths.
        Data files were previously generated for each incumbent.  This re-uses
        those files.
        &#34;&#34;&#34;
        all_path_script = self.WriteAllIncumbentPathsScript()

    def WriteTreeScript(self, additional_lines = None):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate a tree image.
        Args:
          additional_lines: String with additional lines to be added to the
            script file.
        &#34;&#34;&#34;
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._min_objective_value, self._max_objective_value)
        data = &#39;&#39;
        data += &#39;set terminal png notransparent size 480,360\n&#39;
        data += &#39;set output &#34;%s&#34;\n&#39; % output_file
        data += &#39;set nokey\n&#39;
        data += &#39;set autoscale\n&#39;
        data += &#39;set tics scale 0.001\n&#39;
        data += &#39;set pointsize 0.5\n&#39;
        data += &#39;set xrange [-0.1:1.1]\n&#39;
        data += &#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_max_obj,
                                                          image_min_obj)
        data += &#39;set format x &#34;&#34;\n&#39;
        data += &#39;set ylabel &#34;obj. value&#34;\n&#39;
        if self._filename is None:
            data += &#39;set title &#34;B&amp;B tree&#34;\n&#39;
        else:
            data += &#39;set title &#34;B&amp;B tree (%s %.2fs %s)&#34;\n\n&#39; % (
                self._filename, self._time, self._label)
        for line in additional_lines:
            data += line
        return data

    def GetTreeFixedHorizontalPositions(self):
        &#34;&#34;&#34;
        Returns horizontal positions for all nodes based on fixed positions.
        Returns:
          Dictionary of float horizontal positions, keyed by node id.
        &#34;&#34;&#34;
        # Statistics needed for horizontal positions.
        horizontal_lower_bound = dict.fromkeys(self.get_node_list(), 0.0)
        horizontal_upper_bound = dict.fromkeys(self.get_node_list(), 1.0)
        horizontal_positions = dict.fromkeys(self.get_node_list())
        horizontal_positions[self.root.name] = 0.5
        # sort node list
        node_id_list = sorted(self.get_node_list())
        node_id_list_int = list(int(n) for n in node_id_list)
        node_id_list_int = sorted(node_id_list_int)
        node_id_list = list(str(n) for n in node_id_list_int)
        for node_id in node_id_list:
            if node_id == self.root.name:
                continue
            parent_id = self.get_node_attr(node_id, &#39;parent&#39;)
            branch_direction = self.get_node_attr(node_id, &#39;direction&#39;)
            if branch_direction == &#39;R&#39;:
                horizontal_lower_bound[node_id] = horizontal_positions[
                    parent_id]
                horizontal_upper_bound[node_id] = horizontal_upper_bound[
                    parent_id]
            elif branch_direction == &#39;L&#39;:
                horizontal_lower_bound[node_id] = horizontal_lower_bound[
                    parent_id]
                horizontal_upper_bound[node_id] = horizontal_positions[
                    parent_id]
            else:
                print(&#39;Error: node %s has unsupported branching direction.&#39;\
                    %node_id)
                print(&#39;Fixed-position tree images only support L and R &#39;)
                print(&#39;branching.&#39;)
                sys.exit(1)
            horizontal_positions[node_id] = old_div((
                horizontal_upper_bound[node_id] +
                horizontal_lower_bound[node_id]), 2)
        return horizontal_positions

    def GetTreeHorizontalPositions(self):
        &#34;&#34;&#34;
        Returns horizontal positions for all nodes.
        Each node is given equal horizontal space.
        Returns:
          Dictionary of float horizontal positions, keyed by node id.
        &#34;&#34;&#34;
        # Statistics needed for horizontal positions.
        number_descendants = dict.fromkeys(self.get_node_list(), 1)
        # number_descendants includes the key node itself
        horizontal_lower_bound = dict.fromkeys(self.get_node_list(), 0.0)
        horizontal_upper_bound = dict.fromkeys(self.get_node_list(), 1.0)
        horizontal_positions = dict.fromkeys(self.get_node_list())
        visited = dict.fromkeys(self.get_node_list(), False)
        # Count the number of descendants for each node.
        # Do a post-order traversal of the tree.
        node_stack = []
        node_stack.append(self.root.name)
        while node_stack:
            current_node = node_stack[len(node_stack) - 1]
            lchild = self.get_left_child(current_node)
            rchild = self.get_right_child(current_node)
            is_node_added = False
            # Add the next unvisited child to the stack
            if lchild is not None and not visited[quote(lchild)]:
                node_stack.append(lchild)
                is_node_added = True
            if (rchild is not None and not visited[quote(rchild)] and
                is_node_added==False):
                node_stack.append(rchild)
                is_node_added = True
            # If all childs visited, then update number_descendants
            if not is_node_added:
                if lchild is not None:
                    number_descendants[quote(current_node)] += (
                                number_descendants[quote(lchild)])
                if rchild is not None:
                    number_descendants[quote(current_node)] += (
                                number_descendants[quote(rchild)])
                visited[quote(current_node)] = True
                del node_stack[len(node_stack) - 1]
        # Traverse the tree and set horizontal positions.
        # Do a pre-order traversal of the tree.
        node_stack = []
        node_stack.append(self.root.name)
        horizontal_lower_bound[self.root.name] = 0.0
        horizontal_upper_bound[self.root.name] = 1.0
        while node_stack:
            node = node_stack.pop()
            lchild = self.get_left_child(node)
            rchild = self.get_right_child(node)
            direction = None
            number_of_children = 0
            children_list = []
            # Place all children on the stack
            if lchild is not None:
                node_stack.append(lchild)
                number_of_children += 1
                direction = &#39;L&#39;
                children_list.append(lchild)
            if rchild is not None:
                node_stack.append(rchild)
                number_of_children += 1
                direction = &#39;R&#39;
                children_list.append(rchild)
            # Convenience variables
            current_lower_bound = horizontal_lower_bound[quote(node)]
            current_range = (horizontal_upper_bound[quote(node)] -
                             horizontal_lower_bound[quote(node)])
            total_descendants = number_descendants[quote(node)]
            sorted_child_labels = sorted(children_list)
            # Determine where to place this node with respect to its children.
            # Put the node in the center, or have more children on the left.
            before_index = int(math.ceil(old_div(number_of_children,2.0)))
            # Exception with a single node that is &#39;L&#39;
            if number_of_children == 1:
                if direction != &#39;L&#39;:
                    before_index = 0
            cumulative_descendants = 0
            for i, label in enumerate(sorted_child_labels):
                if before_index == i:
                    # Determine the relative position for the current node
                    relative_position = old_div((cumulative_descendants + 0.5), (
                        total_descendants))
                    cumulative_descendants += 1
                # Set bounds for this child
                horizontal_lower_bound[quote(label)] = (
                    current_lower_bound + float(cumulative_descendants) /
                    total_descendants * current_range)
                # Increment cumulative_descendants, which also lets us compute
                # the upper bound.
                cumulative_descendants += number_descendants[quote(label)]
                horizontal_upper_bound[quote(label)] = (
                    current_lower_bound + float(cumulative_descendants) /
                    total_descendants * current_range)
            # Catch the case that the node comes after all its children.
            # This must also work for the case that this is the only node.
            if before_index == len(sorted_child_labels):
                relative_position = old_div((cumulative_descendants + 0.5), (
                    total_descendants))
            # Finally set the position for the current node
            horizontal_positions[quote(node)] = (
                horizontal_lower_bound[quote(node)] + relative_position * (
                    horizontal_upper_bound[quote(node)] -
                    horizontal_lower_bound[quote(node)]))
        return horizontal_positions

    def WriteDataFileFromList(self, filename, data_list):
        &#34;&#34;&#34;
        Write a list of string data to a file with one entry per line.
        Args:
          filename: String filename to open.
          data_list: List of string values to write.
        &#34;&#34;&#34;
        outfile = open(filename, &#39;w&#39;)
        for line in data_list:
            outfile.write(line)
        outfile.close()

    def GenerateTreeImage(self, fixed_horizontal_positions = False):
        &#34;&#34;&#34;
        Generate files necessary for a tree image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        &#34;&#34;&#34;
        index_string = self.GetImageCounterString()
        if fixed_horizontal_positions:
            name_prefix = &#39;tree_alt&#39;
            horizontal_positions = self.GetTreeFixedHorizontalPositions()
        else:
            name_prefix = &#39;tree&#39;
            horizontal_positions = self.GetTreeHorizontalPositions()
        candidate_lines = []
        pregnant_lines = []
        branched_lines = []
        infeasible_lines = []
        fathomed_lines = []
        integer_lines = []
        additional_script_lines = []
        node_list = self.get_node_list()
        print_edges = (len(node_list) &lt;= self._edge_limit)
        for node in node_list:
            node_lp_bound = self.get_node_attr(node, &#39;lp_bound&#39;)
            if self.get_node_attr(node, &#39;status&#39;) == &#39;candidate&#39;:
                # TODO(bhunsaker): add optional fathoming check
                candidate_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;pregnant&#39;:
                # TODO(bhunsaker): add optional fathoming check
                pregnant_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;branched&#39;:
                branched_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;infeasible&#39;:
                infeasible_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;fathomed&#39;:
                fathomed_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;integer&#39;:
                integer_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            if print_edges and node != self.root.name:
                if True:
                    _parent_id = self.get_node_attr(node, &#39;parent&#39;)
                    additional_script_lines.append(
                     &#39;set arrow from %0.6f, %0.6f to %0.6f, %0.6f nohead lt -1 &#39;
                     &#39;lw 0.2\n&#39; % (horizontal_positions[_parent_id],
                     self.get_node_attr(_parent_id, &#39;lp_bound&#39;),
                     horizontal_positions[node],
                     self.get_node_attr(node, &#39;lp_bound&#39;)))
        plot_parts = []
        # Plot root node.
        plot_parts.append(&#39;&#34;&lt; echo %0.6f %0.6f&#34; w p lt 2 pt 7&#39; %
                          (horizontal_positions[self.root.name],
                           self.root.get_attr(&#39;lp_bound&#39;)))
        # If desired, sample from the set of nodes rather than plotting all.
        if self._sample_tree:
            sample_size = self._sample_tree
            if len(branched_lines) &gt; sample_size:
                branched_lines = random.sample(branched_lines, sample_size)
            if len(fathomed_lines) &gt; sample_size:
                fathomed_lines = random.sample(fathomed_lines, sample_size)
            if len(infeasible_lines) &gt; sample_size:
                infeasible_lines = random.sample(infeasible_lines, sample_size)
            if len(pregnant_lines) &gt; sample_size:
                pregnant_lines = random.sample(pregnant_lines, sample_size)
            if len(candidate_lines) &gt; sample_size:
                candidate_lines = random.sample(candidate_lines, sample_size)
            if len(integer_lines) &gt; sample_size:
                integer_lines = random.sample(integer_lines, sample_size)
        # Output all data files.  Note that the order below matters.
        if len(branched_lines):
            self.WriteDataFileFromList(&#39;%s_branched%s.dat&#39; % (name_prefix,
                                                              index_string),
                                       branched_lines)
            plot_parts.append(&#39;\&#39;%s_branched%s.dat\&#39; w p lt rgb &#34;yellow&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(fathomed_lines):
            self.WriteDataFileFromList(&#39;%s_fathomed%s.dat&#39; % (name_prefix,
                                                              index_string),
                                       fathomed_lines)
            plot_parts.append(&#39;\&#39;%s_fathomed%s.dat\&#39; w p lt rgb &#34;light-red&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(infeasible_lines):
            self.WriteDataFileFromList(&#39;%s_infeasible%s.dat&#39; % (name_prefix,
                                                                index_string),
                                       infeasible_lines)
            plot_parts.append(&#39;\&#39;%s_infeasible%s.dat\&#39; w p lt rgb &#34;dark-red&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(pregnant_lines):
            self.WriteDataFileFromList(&#39;%s_pregnant%s.dat&#39; % (name_prefix,
                                                              index_string),
                                       pregnant_lines)
            plot_parts.append(&#39;\&#39;%s_pregnant%s.dat\&#39; w p lt rgb &#34;green&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(candidate_lines):
            for line in candidate_lines:
                plot_parts.append(&#39;&#34;&lt; echo %s&#34; w p lt rgb &#34;green&#34; pt 7&#39;
                                  %line.rstrip(&#39;\r\n&#39;))
        if len(integer_lines):
            self.WriteDataFileFromList(&#39;%s_integer%s.dat&#39; % (name_prefix,
                                                             index_string),
                                       integer_lines)
            plot_parts.append(&#39;\&#39;%s_integer%s.dat\&#39; w p lt rgb &#34;cyan&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if self._incumbent_value is not None:
            plot_parts.append(&#39;%0.6f lt 1 lw 0.5&#39; % self._incumbent_value)
        additional_script_lines.append(&#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts))
        additional_script_lines.append(&#39;unset arrow\n&#39;)
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._min_objective_value, self._max_objective_value)
        data = &#39;&#39;
        data += &#39;set terminal png notransparent size 480,360\n&#39;
        data += &#39;set nokey\n&#39;
        data += &#39;set autoscale\n&#39;
        data += &#39;set tics scale 0.001\n&#39;
        data += &#39;set pointsize 0.5\n&#39;
        data += &#39;set xrange [-0.1:1.1]\n&#39;
        data += &#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_max_obj,
                                                          image_min_obj)
        data += &#39;set format x &#34;&#34;\n&#39;
        data += &#39;set ylabel &#34;obj. value&#34;\n&#39;
        if self._filename is None:
            data += &#39;set title &#34;B&amp;B tree&#34;\n\n&#39;
        else:
            data += &#39;set title &#34;B&amp;B tree (%s %.2fs %s)&#34;\n\n&#39; % (
                self._filename, self._time, self._label)
        for line in additional_script_lines:
            data += line

        return data

    def ProcessLine(self, line):
        &#34;&#34;&#34;
        Process a line of the input file, generating images if appropriate.
        Parses the line, updates internal data structures, and creates images
        if appropriate.
        Args:
          line: String input line to process.
        &#34;&#34;&#34;
        line = line.strip()
        # Comments start with a &#39;#&#39;
        if line[0] == &#39;#&#39;:
            return
        tokens = line.split()
        if len(tokens) &lt; 3:
            print(&#39;Incomplete or invalid line: %s&#39; %&#39; &#39;.join(tokens))
            sys.exit(1)
        # Tokens shared by all line types
        self._time = float(tokens[0])
        line_type = tokens[1]
        remaining_tokens = tokens[2:]
        # Process the line based on the type
        if line_type == &#39;heuristic&#39;:
            self._optimal_soln_time = self._time
            self.ProcessHeuristicLine(remaining_tokens)
        else:
            # Other node types share common tokens
            node_id = int(tokens[2])
            parent_id = int(tokens[3])
            branch_direction = tokens[4]
            remaining_tokens = tokens[5:]
            # TODO(aykut):parent id of root node is 0 when we read from file.
            if id==self.root:
                parent_id = None
            # Check that the parent node id is valid
            # elif parent_id not in self.get_node_list() and self.root is not None:
            #     print &#39;Parent id does not exist: %s&#39; % line
            #     sys.exit(1)
            if line_type == &#39;integer&#39;:
                self._optimal_soln_time = self._time
                self.ProcessIntegerLine(node_id, parent_id,
                                        branch_direction, remaining_tokens)
            elif line_type == &#39;fathomed&#39;:
                self.ProcessFathomedLine(node_id, parent_id,
                                         branch_direction, remaining_tokens)
            elif line_type == &#39;candidate&#39;:
                self.ProcessCandidateLine(node_id, parent_id,
                                          branch_direction, remaining_tokens)
            elif line_type == &#39;pregnant&#39;:
                self.ProcessPregnantLine(node_id, parent_id,
                                         branch_direction, remaining_tokens)
            elif line_type == &#39;branched&#39;:
                self.ProcessBranchedLine(node_id, parent_id,
                                         branch_direction, remaining_tokens)
            elif line_type == &#39;infeasible&#39;:
                self.ProcessInfeasibleLine(node_id, parent_id,
                                           branch_direction, remaining_tokens)
            else:
                print(&#39;Unexpected line type &#34;%s&#34;: %s&#39; % (line_type,
                                                         &#39; &#39;.join(tokens)))
                sys.exit(1)

    def ProcessHeuristicLine(self, remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;heuristic&#39;.
        Args:
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) &lt; 1 or len(remaining_tokens) &gt; 2:
            print(&#39;Invalid line: %s heuristic %s&#39; % (
                    self._time, &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; heuristic &lt;obj value&gt;&#39;+\
                &#39; [&lt;associated node id&gt;]&#39;)
            sys.exit(1)
        objective_value = float(remaining_tokens[0])
        if len(remaining_tokens) == 2:
            associated_node = remaining_tokens[1]
        else:
            associated_node = None
        # Check that this is actually an improvement
        if self._incumbent_value is not None and self._optimization_sense is None:
            if objective_value &gt; self._incumbent_value:
                print(&#34;Objective sense unset, guessing maximization&#34;)
                self._optimization_sense = &#39;max&#39;
            else:
                print(&#34;Objective sense unset, guessing minimization&#34;)
                self._optimization_sense = &#39;min&#39;
        if not self.IsBetterThanIncumbent(objective_value):
            return
        self._previous_incumbent_value = self._incumbent_value
        self._incumbent_value = objective_value
        self.UpdateObjectiveValueLimits(objective_value)
        self._incumbent_parent = associated_node
        # Set variable to generate images
        self._new_integer_solution = True

    def ProcessIntegerLine(self, node_id, parent_id, branch_direction,
                           remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;integer&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
          is the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) != 1:
            print(&#39;Invalid line: %s integer %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; integer &lt;node id&gt; &lt;parent id&gt;&#39;+\
                &#39;&lt;branch direction&gt; &lt;obj value&gt;&#39;)
            sys.exit(1)
        objective_value = float(remaining_tokens[0])
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;integer&#39;,
                             objective_value, None, None)
        self._previous_incumbent_value = self._incumbent_value
        self._incumbent_value = objective_value
        self._incumbent_parent = parent_id
        self._new_integer_solution = True

    def ProcessFathomedLine(self, node_id, parent_id, branch_direction,
                            remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;fathomed&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
            the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Print a warning if there is no current incumbent.
        if self._incumbent_value is None:
            print(&#39;WARNING: Encountered &#34;fathom&#34; line before first incumbent.&#39;)
            print(&#39;  This may indicate an error in the input file.&#39;)
        # Parse remaining tokens
        if len(remaining_tokens) &gt; 1:
            print(&#39;Invalid line: %s fathomed %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; fathomed &lt;node id&gt; &lt;parent id&gt;&#39;+\
                &#39;&lt;branch direction&gt; [&lt;lp bound&gt;]&#39;)
            sys.exit(1)
        if len(remaining_tokens) == 1:
            lp_bound = float(remaining_tokens[0])
        else:
            if (node_id in self.get_node_list() and
                self.get_node_attr(node_id, &#39;lp_bound&#39;) is not None):
                lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
            else:
                lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
            if self._optimization_sense == &#39;min&#39;:
                if (self._incumbent_value is not None and
                    lp_bound &lt; self._incumbent_value):
                    lp_bound = self._incumbent_value
            elif self._optimization_sense == &#39;max&#39;:
                if (self._incumbent_value is not None and
                    lp_bound &gt; self._incumbent_value):
                    lp_bound = self._incumbent_value
        parent_node = self.get_node(parent_id)
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;fathomed&#39;,
                             lp_bound,
                             self.get_node_attr(parent_id,
                                                &#39;integer_infeasibility_count&#39;),
                             self.get_node_attr(parent_id,
                                                &#39;integer_infeasibility_sum&#39;))

    def ProcessPregnantLine(self, node_id, parent_id, branch_direction,
                            remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;pregnant&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
            the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) != 3:
            print(&#39;Invalid line: %s pregnant %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; pregnant &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt; &lt;lp bound&gt; &#39;)
            print(&#39;&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
            print(&#39;infeasibilities&gt;&#39;)
            sys.exit(1)
        lp_bound = float(remaining_tokens[0])
        integer_infeasibility_sum = float(remaining_tokens[1])
        integer_infeasibility_count = int(remaining_tokens[2])

        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;pregnant&#39;,
                             lp_bound, integer_infeasibility_count,
                             integer_infeasibility_sum)

    def ProcessBranchedLine(self, node_id, parent_id, branch_direction,
                            remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;branched&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
          is the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) not in [3, 5]:
            print(&#39;Invalid line: %s branched %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; branched &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt; &lt;lp bound&gt; &#39;)
            print(&#39;&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
            print(&#39;infeasibilities&gt;&#39;)
            sys.exit(1)
        lp_bound = float(remaining_tokens[0])
        integer_infeasibility_sum = float(remaining_tokens[1])
        integer_infeasibility_count = int(remaining_tokens[2])
        condition_begin = None
        condition_end = None
        if len(remaining_tokens) == 5:
            # In this case, we must also be printing conditions numbers
            condition_begin = int(remaining_tokens[3])
            condition_end = int(remaining_tokens[4])
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;branched&#39;,
                             lp_bound, integer_infeasibility_count,
                             integer_infeasibility_sum, condition_begin,
                             condition_end)

    def ProcessInfeasibleLine(self, node_id, parent_id, branch_direction,
                              remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;infeasible&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
            the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) not in [0, 2]:
            print(&#39;Invalid line: %s infeasible %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; infeasible &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt;&#39;)
            sys.exit(1)
        # Use parent values if the node does not have its own
        lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
        ii_count = self.get_node_attr(parent_id, &#39;integer_infeasibility_count&#39;)
        ii_sum = self.get_node_attr(parent_id, &#39;integer_infeasibility_sum&#39;)
        if node_id in self.get_node_list():
            if self.get_node_attr(node_id, &#39;lp_bound&#39;) is not None:
                lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
            if (self.get_node_attr(node_id, &#39;integer_infeasibility_count&#39;)
                is not None):
                ii_count = self.get_node_attr(node_id,
                                              &#39;integer_infeasibility_count&#39;)
            if (self.get_node_attr(node_id, &#39;integer_infeasibility_sum&#39;)
                is not None):
                ii_sum = self.get_node_attr(node_id,&#39;integer_infeasibility_sum&#39;)
        if len(remaining_tokens) == 2:
            # In this case, we must also be printing conditions numbers
            condition_begin = int(remaining_tokens[0])
            condition_end = int(remaining_tokens[1])
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;infeasible&#39;,
                             lp_bound, ii_count, ii_sum)

    def ProcessCandidateLine(self, node_id, parent_id, branch_direction,
                             remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;candidate&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
          is the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) == 2 or len(remaining_tokens) &gt; 3:
            print(&#39;Invalid line: %s branched %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; candidate &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt; [&lt;lp bound&gt;] &#39;)
            print(&#39;[&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
            print(&#39;infeasibilities&gt;]&#39;)
            sys.exit(1)
        # if parent_id not in self.get_node_list():
        #     print &#39;Error: node %s not in set&#39; % parent_id
        #     sys.exit(1)
        # TODO(bhunsaker): Check that we handle the cases of updating a
        #candidate.
        if len(remaining_tokens) &gt; 0:
            lp_bound = float(remaining_tokens[0])
        else:
            lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
        if len(remaining_tokens) == 3:
            integer_infeasibility_sum = float(remaining_tokens[1])
            integer_infeasibility_count = int(remaining_tokens[2])
        else:
            integer_infeasibility_sum = self.get_node_attr(parent_id,
                                                  &#39;integer_infeasibility_sum&#39;)
            integer_infeasibility_count = self.get_node_attr(parent_id,
                                                &#39;integer_infeasibility_count&#39;)
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;candidate&#39;,
                             lp_bound, integer_infeasibility_count,
                             integer_infeasibility_sum)

    def RunGnuplotOnAllFiles(self):
        &#34;&#34;&#34;Runs Gnuplot on all files in self._gnuplot_files.&#34;&#34;&#34;
        for file in self._gnuplot_files:
            subprocess.call([&#39;gnuplot&#39;, file])

    def CreateAnimatedImages(self):
        &#34;&#34;&#34;Create animated images based on the static images.&#34;&#34;&#34;
        histogram_re = re.compile(&#39;histogram&#39;)
        histogram_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                            for file in self._gnuplot_files
                            if histogram_re.match(file)]
        if len(histogram_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(histogram_images)
            args.append(&#39;animated_histogram.gif&#39;)
            subprocess.call(args)
        scatterplot_re = re.compile(&#39;scatterplot&#39;)
        scatterplot_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                              for file in self._gnuplot_files
                              if scatterplot_re.match(file)]
        if len(scatterplot_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(scatterplot_images)
            args.append(&#39;animated_scatterplot.gif&#39;)
            subprocess.call(args)
        tree_re = re.compile(&#39;tree\.&#39;)
        tree_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                       for file in self._gnuplot_files
                       if tree_re.match(file)]
        if len(tree_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(tree_images)
            args.append(&#39;animated_tree.gif&#39;)
            subprocess.call(args)
        tree_alt_re = re.compile(&#39;tree_alt&#39;)
        tree_alt_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                           for file in self._gnuplot_files
                           if tree_alt_re.match(file)]
        if len(tree_alt_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(tree_alt_images)
            args.append(&#39;animated_tree_alt.gif&#39;)
            subprocess.call(args)

    def GeneratePredictionImages(self):
        gap_measures = self._objective_gap_forecaster.GetAllMeasures()
        ssg_measures = self._sum_subtree_gaps_forecaster.GetAllMeasures()
        # Check that there are values to process.
        if len(gap_measures) == 0 or len(ssg_measures) == 0:
            print(&#39;WARNING: Not printing prediction images because at least&#39;+\
                &#39; one measure set is empty.&#39;)
            print(&#39;  Gap measures: %d&#39; % len(gap_measures))
            print(&#39;  SSG measures: %d&#39; % len(ssg_measures))
            return
        # Gap measures
        gap_data_filename = &#39;gap_measures.dat&#39;
        data_file = open(gap_data_filename, &#39;w&#39;)
        for measure in gap_measures:
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (measure.time, measure.value))
        data_file.close()
        # SSG measures
        ssg_data_filename = &#39;ssg_measures.dat&#39;
        data_file = open(ssg_data_filename, &#39;w&#39;)
        # We need to scale the SSG measures so that it will make sense to
        # look at them on the same plot with gap measures.
        scale_factor=old_div(float(gap_measures[0].value),float(ssg_measures[0].value))
        for measure in ssg_measures:
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (measure.time,
                                               measure.value * scale_factor))
        data_file.close()
        # Set terminal for the output files.
        measures_script = &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the plot.
        if self.filename is None:
            measures_script += &#39;set title &#34;Progress Measures&#34;\n&#39;
        else:
            measures_script += (&#39;set title &#34;Progress Measures: %s, %s&#34;\n&#39; % (
                    self._filename, self._label))
        measures_script += &#39;set xlabel \&#34;time (s)\&#34;\n&#39;
        measures_script += &#39;set ylabel \&#34;measure\&#34;\n&#39;
        measures_script += &#39;set autoscale\n&#39;
        # Plot the data points.
        measures_script += (
            &#39;plot \&#39;%s\&#39; with linespoints linetype 3 title \&#34;(SSG)\&#34;, &#39;
            &#39;\&#39;%s\&#39; with linespoints linetype 4 pointtype 19 &#39;
            &#39;title \&#34;(MIP gap)\&#34;\n&#39; %
            (ssg_data_filename, gap_data_filename))
        measures_script += &#39;show output\n&#39;

        return measures_script

    def GenerateForecastImages(self):
        # Forecasts
        # Gap forecasts
        gap_forecasts = self._objective_gap_forecaster.GetAllForecasts()
        gap_data_filename = &#39;gap_forecasts.dat&#39;
        if gap_forecasts:
            data_file = open(gap_data_filename, &#39;w&#39;)
            for forecast in gap_forecasts:
                data_file.write(&#39;%0.6f %0.6f\n&#39; % (forecast.time,
                                                   forecast.forecast))
            data_file.close()
        # SSG forecasts
        ssg_forecasts = self._sum_subtree_gaps_forecaster.GetAllForecasts()
        ssg_data_filename = &#39;ssg_forecasts.dat&#39;
        if ssg_forecasts:
            data_file = open(ssg_data_filename, &#39;w&#39;)
            for forecast in ssg_forecasts:
                data_file.write(&#39;%0.6f %0.6f\n&#39; % (forecast.time,
                                                   forecast.forecast))
            data_file.close()
        if not gap_forecasts and not ssg_forecasts:
            print(&#39;No forecasts made, so not creating forecast image.&#39;)
            return
        # Set terminal for the output files.
        forecast_script = &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the plot.
        if self._filename is None:
            forecast_script += &#39;set title &#34;Forecasts&#34;\n&#39;
        else:
            forecast_script += (&#39;set title &#34;Forecasts: %s, %s&#34;\n&#39; % (
                    self._filename, self._label))
        forecast_script += &#39;set xlabel \&#34;time (s)\&#34;\n&#39;
        forecast_script += &#39;set ylabel \&#34;prediction of total time\&#34;\n&#39;
        forecast_script += &#39;set autoscale\n&#39;
        # Plot the data points and the unit-slope line (to show elapsed time).
        forecast_script += &#39;plot &#39;
        if forecast_forecasts:
            forecast_script += (&#39;\&#39;%s\&#39; with linespoints linetype 3 &#39;
                              &#39;title \&#34;(SSG)\&#34;, &#39; % ssg_data_filename)
        if gap_forecasts:
            forecast_script += (&#39;\&#39;%s\&#39; with linespoints linetype 4 pointtype 19 &#39;
            &#39;title \&#34;(MIP gap)\&#34;, &#39; % gap_data_filename)
        forecast_script += &#39;x linetype 0 title \&#34;elapsed time\&#34;\n&#39;
        forecast_script += &#39;show output\n&#39;

        return forecast_script

    def _get_fh(self, path, mode=&#39;r&#39;):
        &#39;&#39;&#39;
        Return a file handle for given path.
        Path can be a string or a file handle.
        Attempt to uncompress/compress files ending in &#39;.gz&#39; and &#39;.bz2&#39;.
        &#39;&#39;&#39;
        if self._is_string_like(path):
            if path.endswith(&#39;.gz&#39;):
#               import gzip
#               fh = gzip.open(path,mode=mode)  # doesn&#39;t return real fh
                fh=os.popen(&#34;gzcat &#34;+path) # probably not portable
            elif path.endswith(&#39;.bz2&#39;):
#               import bz2
#               fh = bz2.BZ2File(path,mode=mode) # doesn&#39;t return real fh
                fh=os.popen(&#34;bzcat &#34;+path) # probably not portable
            else:
                fh = file(path,mode=mode)
        elif hasattr(path, &#39;write&#39;):
            # Note, mode of file handle is unchanged.
            fh = path
        else:
            raise TypeError(&#39;path must be a string or file handle.&#39;)
        return fh

    def _is_string_like(self, obj): # from John Hunter, types-free version
        try:
            obj + &#39;&#39;
        except (TypeError, ValueError):
            return False
        return True

def CreatePerlStyleBooleanFlag(parser, flag_text, variable_name, help_text):
    &#34;&#34;&#34;
    Add two options to an optparse.OptionParser, one with a &#39;no&#39; prefix.
    Two options are created.  One has the flag_text and one has &#39;no&#39; prepended
    to the flag_text.  For example, --foo and --nofoo.  This is similar to a
    common style in Perl.
    Args:
      parser: optparse.OptionParser object.
      flag_text: String text for the flag.
      variable_name: String name of the variable to store the flag results.
      help_text: String that describes the flag.
    &#34;&#34;&#34;
    parser.add_option(&#39;--&#39; + flag_text,
                      action=&#39;store_true&#39;, dest=variable_name, default=False,
                      help=help_text)
    parser.add_option(&#39;--no&#39; + flag_text,
                      action=&#39;store_false&#39;, dest=variable_name,
                      help=&#39;do not &#39; + flag_text)

def parse_options():
    &#39;&#39;&#39; Parse arguments and flags&#39;&#39;&#39;
    usage_text = &#39;usage: %prog [options] &lt;input file&gt;&#39;
    parser = optparse.OptionParser(usage=usage_text)

    parser.add_option(&#39;--interval&#39;, dest=&#39;interval&#39;, type=&#39;float&#39;,
                      default=10.0,
                      help=&#39;generate images every TIME seconds&#39;,
                      metavar=&#39;TIME&#39;)
    parser.add_option(&#39;--time_limit&#39;, dest=&#39;time_limit&#39;, type=&#39;float&#39;,
                      help=&#39;process at most TIME seconds of solver time&#39;,
                      metavar=&#39;TIME&#39;)
    parser.add_option(&#39;--label&#39;, dest=&#39;label&#39;, default=&#39;&#39;,
                      help=&#39;add LABEL to all images&#39;,
                      metavar=&#39;LABEL&#39;)
    parser.add_option(&#39;--use_common_bounds&#39;, dest=&#39;use_common_bounds&#39;,
                      action=&#39;store_true&#39;, default=False,
                      help=&#39;use the same bounds on all images&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;fathom&#39;, &#39;fathom&#39;,
                               &#39;do an interval check for fathomed nodes&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;histogram&#39;, &#39;histogram&#39;,
                               &#39;print histograms&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;scatterplot&#39;, &#39;scatterplot&#39;,
                               &#39;print scatterplots&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;path&#39;, &#39;path&#39;,
                               &#39;print scatterplot incumbent paths&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;tree&#39;, &#39;tree&#39;,
                               &#39;print tree images&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;fixed_tree&#39;, &#39;fixed_tree&#39;,
                               &#39;print tree images with fixed horizontal &#39;
                               &#39;positions&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;predictions&#39;, &#39;predictions&#39;,
                               &#39;print time predictions&#39;)
    parser.add_option(&#39;--all&#39;, dest=&#39;all_images&#39;, action=&#39;store_true&#39;,
                      default=False, help=&#39;print all images&#39;)
    parser.add_option(&#39;--logscaley&#39;, dest=&#39;logscaley&#39;,
                      action=&#39;store_true&#39;, default=False,
                      help=&#39;use log scale for histogram sizes&#39;)
    parser.add_option(&#39;--animate&#39;, dest=&#39;animate&#39;,
                      action=&#39;store_true&#39;, default=False,
                      help=&#39;create animated GIF of each image set&#39;)
    parser.add_option(&#39;--no_run_gnuplot&#39;, dest=&#39;run_gnuplot&#39;,
                      action=&#39;store_false&#39;, default=True,
                      help=&#39;do not run Gnuplot on the generated files&#39;)
    parser.add_option(&#39;--edge_limit&#39;, dest=&#39;edge_limit&#39;, type=&#39;int&#39;,
                      default=1000000,
                      help=&#39;do not print edges in tree plots if more than &#39;
                      &#39;NUM nodes&#39;,
                      metavar=&#39;NUM&#39;)
    parser.add_option(&#39;--sample_tree&#39;, dest=&#39;sample_tree&#39;, type=&#39;int&#39;,
                      default=0,
                      help=&#39;use at most NUM nodes of each type in tree images;&#39;
                      &#39; zero means no limit&#39;,
                      metavar=&#39;NUM&#39;)
    (options, args) = parser.parse_args()
    if (len(args) != 1):
        parser.print_usage()
        sys.exit(1)
    input_filename = args[0]
    if options.all_images:
        options.histogram = True
        options.scatterplot = True
        options.path = True
        options.tree = True
        options.fixed_tree = True
        options.predictions = True
    # Abort if no images chosen
    if (not options.histogram and not options.scatterplot and
        not options.path and not options.tree and not options.fixed_tree and
        not options.predictions):
        print(&#39;No image types specified so not processing.&#39;)
        parser.print_usage()
        sys.exit(1)
    # Bounds for incumbent paths will be undefined without scatterplots.
    if options.path:
        options.scatterplot = True
    # TODO(bhunsaker): Check whether Gnuplot can be accessed early.
    # TODO(bhunsaker): Check whether animation program can be accessed.
    if (len(args) != 1):
        parser.print_usage()
        sys.exit(1)
    if options.all_images:
        options.histogram = True
        options.scatterplot = True
        options.path = True
        options.tree = True
        options.fixed_tree = True
        options.predictions = True
    # Abort if no images chosen
    if (not options.histogram and not options.scatterplot and
        not options.path and not options.tree and not options.fixed_tree and
        not options.predictions):
        print(&#39;No image types specified so not processing.&#39;)
        sys.exit(1)
    # Bounds for incumbent paths will be undefined without scatterplots.
    if options.path:
        options.scatterplot = True
    return (input_filename, options)


if __name__ == &#39;__main__&#39;:
    from .BranchAndBound import GenerateRandomMIP, BranchAndBound

    T = BBTree()
    #T.set_layout(&#39;dot2tex&#39;)
    #T.set_display_mode(&#39;file&#39;)
    T.set_display_mode(&#39;matplotlib&#39;)
    CONSTRAINTS, VARIABLES, OBJ, MAT, RHS = GenerateRandomMIP(rand_seed = 120)
    BranchAndBound(T, CONSTRAINTS, VARIABLES, OBJ, MAT, RHS,
                   branch_strategy = MOST_FRACTIONAL,
                   search_strategy = BEST_FIRST,
                   display_interval = 10000)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="coinor.grumpy.BBTree.CreatePerlStyleBooleanFlag"><code class="name flex">
<span>def <span class="ident">CreatePerlStyleBooleanFlag</span></span>(<span>parser, flag_text, variable_name, help_text)</span>
</code></dt>
<dd>
<div class="desc"><p>Add two options to an optparse.OptionParser, one with a 'no' prefix.
Two options are created.
One has the flag_text and one has 'no' prepended
to the flag_text.
For example, &ndash;foo and &ndash;nofoo.
This is similar to a
common style in Perl.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong></dt>
<dd>optparse.OptionParser object.</dd>
<dt><strong><code>flag_text</code></strong></dt>
<dd>String text for the flag.</dd>
<dt><strong><code>variable_name</code></strong></dt>
<dd>String name of the variable to store the flag results.</dd>
<dt><strong><code>help_text</code></strong></dt>
<dd>String that describes the flag.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreatePerlStyleBooleanFlag(parser, flag_text, variable_name, help_text):
    &#34;&#34;&#34;
    Add two options to an optparse.OptionParser, one with a &#39;no&#39; prefix.
    Two options are created.  One has the flag_text and one has &#39;no&#39; prepended
    to the flag_text.  For example, --foo and --nofoo.  This is similar to a
    common style in Perl.
    Args:
      parser: optparse.OptionParser object.
      flag_text: String text for the flag.
      variable_name: String name of the variable to store the flag results.
      help_text: String that describes the flag.
    &#34;&#34;&#34;
    parser.add_option(&#39;--&#39; + flag_text,
                      action=&#39;store_true&#39;, dest=variable_name, default=False,
                      help=help_text)
    parser.add_option(&#39;--no&#39; + flag_text,
                      action=&#39;store_false&#39;, dest=variable_name,
                      help=&#39;do not &#39; + flag_text)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.parse_options"><code class="name flex">
<span>def <span class="ident">parse_options</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse arguments and flags</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_options():
    &#39;&#39;&#39; Parse arguments and flags&#39;&#39;&#39;
    usage_text = &#39;usage: %prog [options] &lt;input file&gt;&#39;
    parser = optparse.OptionParser(usage=usage_text)

    parser.add_option(&#39;--interval&#39;, dest=&#39;interval&#39;, type=&#39;float&#39;,
                      default=10.0,
                      help=&#39;generate images every TIME seconds&#39;,
                      metavar=&#39;TIME&#39;)
    parser.add_option(&#39;--time_limit&#39;, dest=&#39;time_limit&#39;, type=&#39;float&#39;,
                      help=&#39;process at most TIME seconds of solver time&#39;,
                      metavar=&#39;TIME&#39;)
    parser.add_option(&#39;--label&#39;, dest=&#39;label&#39;, default=&#39;&#39;,
                      help=&#39;add LABEL to all images&#39;,
                      metavar=&#39;LABEL&#39;)
    parser.add_option(&#39;--use_common_bounds&#39;, dest=&#39;use_common_bounds&#39;,
                      action=&#39;store_true&#39;, default=False,
                      help=&#39;use the same bounds on all images&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;fathom&#39;, &#39;fathom&#39;,
                               &#39;do an interval check for fathomed nodes&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;histogram&#39;, &#39;histogram&#39;,
                               &#39;print histograms&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;scatterplot&#39;, &#39;scatterplot&#39;,
                               &#39;print scatterplots&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;path&#39;, &#39;path&#39;,
                               &#39;print scatterplot incumbent paths&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;tree&#39;, &#39;tree&#39;,
                               &#39;print tree images&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;fixed_tree&#39;, &#39;fixed_tree&#39;,
                               &#39;print tree images with fixed horizontal &#39;
                               &#39;positions&#39;)
    CreatePerlStyleBooleanFlag(parser, &#39;predictions&#39;, &#39;predictions&#39;,
                               &#39;print time predictions&#39;)
    parser.add_option(&#39;--all&#39;, dest=&#39;all_images&#39;, action=&#39;store_true&#39;,
                      default=False, help=&#39;print all images&#39;)
    parser.add_option(&#39;--logscaley&#39;, dest=&#39;logscaley&#39;,
                      action=&#39;store_true&#39;, default=False,
                      help=&#39;use log scale for histogram sizes&#39;)
    parser.add_option(&#39;--animate&#39;, dest=&#39;animate&#39;,
                      action=&#39;store_true&#39;, default=False,
                      help=&#39;create animated GIF of each image set&#39;)
    parser.add_option(&#39;--no_run_gnuplot&#39;, dest=&#39;run_gnuplot&#39;,
                      action=&#39;store_false&#39;, default=True,
                      help=&#39;do not run Gnuplot on the generated files&#39;)
    parser.add_option(&#39;--edge_limit&#39;, dest=&#39;edge_limit&#39;, type=&#39;int&#39;,
                      default=1000000,
                      help=&#39;do not print edges in tree plots if more than &#39;
                      &#39;NUM nodes&#39;,
                      metavar=&#39;NUM&#39;)
    parser.add_option(&#39;--sample_tree&#39;, dest=&#39;sample_tree&#39;, type=&#39;int&#39;,
                      default=0,
                      help=&#39;use at most NUM nodes of each type in tree images;&#39;
                      &#39; zero means no limit&#39;,
                      metavar=&#39;NUM&#39;)
    (options, args) = parser.parse_args()
    if (len(args) != 1):
        parser.print_usage()
        sys.exit(1)
    input_filename = args[0]
    if options.all_images:
        options.histogram = True
        options.scatterplot = True
        options.path = True
        options.tree = True
        options.fixed_tree = True
        options.predictions = True
    # Abort if no images chosen
    if (not options.histogram and not options.scatterplot and
        not options.path and not options.tree and not options.fixed_tree and
        not options.predictions):
        print(&#39;No image types specified so not processing.&#39;)
        parser.print_usage()
        sys.exit(1)
    # Bounds for incumbent paths will be undefined without scatterplots.
    if options.path:
        options.scatterplot = True
    # TODO(bhunsaker): Check whether Gnuplot can be accessed early.
    # TODO(bhunsaker): Check whether animation program can be accessed.
    if (len(args) != 1):
        parser.print_usage()
        sys.exit(1)
    if options.all_images:
        options.histogram = True
        options.scatterplot = True
        options.path = True
        options.tree = True
        options.fixed_tree = True
        options.predictions = True
    # Abort if no images chosen
    if (not options.histogram and not options.scatterplot and
        not options.path and not options.tree and not options.fixed_tree and
        not options.predictions):
        print(&#39;No image types specified so not processing.&#39;)
        sys.exit(1)
    # Bounds for incumbent paths will be undefined without scatterplots.
    if options.path:
        options.scatterplot = True
    return (input_filename, options)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="coinor.grumpy.BBTree.BBTree"><code class="flex name class">
<span>class <span class="ident">BBTree</span></span>
<span>(</span><span>**attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Methods to process and visualize information about a b&amp;b tree. It can
process an output file (in a specific format, see BAK project in COIN-OR) of
a solver that has three information. See run.py in examples directory fot
this use. Moreover it implements a branch and bound method that can solve
binary programs (0-1 variables only) using PuLP as an LP solver. It provides
different branching and searching strategies. See test_strategies.py in test
directory.</p>
<p>This is the main class of GrUMPy. It inherits BinaryTree from GIMPy and
keeps the entire branch-and-bound tree in self.</p>
<p>API: <strong>init</strong>(self, **attrs)</p>
<h2 id="description">Description</h2>
<p>Class constructor.</p>
<h2 id="input">Input</h2>
<p>attrs: Tree attributes in keyword arguments format. See Graph and
Tree class for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BBTree(BinaryTree):
    &#34;&#34;&#34;
    Methods to process and visualize information about a b&amp;b tree. It can
    process an output file (in a specific format, see BAK project in COIN-OR) of
    a solver that has three information. See run.py in examples directory fot
    this use. Moreover it implements a branch and bound method that can solve
    binary programs (0-1 variables only) using PuLP as an LP solver. It provides
    different branching and searching strategies. See test_strategies.py in test
    directory.

    This is the main class of GrUMPy. It inherits BinaryTree from GIMPy and
    keeps the entire branch-and-bound tree in self.
    &#34;&#34;&#34;
    def __init__(self, **attrs):
        if not &#39;layout&#39; in attrs:
            attrs[&#39;layout&#39;]= &#39;bak&#39;
        BinaryTree.__init__(self, **attrs)
        # User-controlled constant values
        self._label = &#39;&#39;
        self._filename = None
        self._logscaley = False
        self._fathom = False
        self._wait_for_keypress = True
        self._edge_limit = 1000000
        # current time, updated each time we read a new line
        self._time = 0.0
        # use at most NUM nodes of each type in tree images; zero means no limit
        self._sample_tree = 0
        # Instance-dependent constant values
        self._optimization_sense = None
        self._start_time = None
        self._histogram_lower_bound = None
        self._histogram_upper_bound = None
        self._scatterplot_lower_bound = None
        self._scatterplot_upper_bound = None
        self._integer_infeasibility_lower_bound = None
        self._integer_infeasibility_upper_bound = None
        # Changing reference values
        self._image_counter = 0
        self._next_image_time = None
        self._incumbent_value = None
        self._incumbent_parent = None
        self._new_integer_solution = False
        self._max_objective_value = None
        self._min_objective_value = None
        self._max_integer_infeasibility_sum = None
        # List of incumbent path data files, for the all incumbent paths image
        self._incumbent_path_datafiles = []
        # Objects for measuring and predicting progress
        self._objective_gap_forecaster = ForecastingChainedSequences()
        self._sum_subtree_gaps_forecaster = ForecastingChainedSequences()
        self._sum_subtree_gaps_scale = 1.0
        self._previous_incumbent_value = None  # Only needed for SSG
        if &#39;display&#39; in attrs:
            self.set_display_mode(attrs[&#39;display&#39;])
        else:
            self.set_display_mode(&#39;off&#39;)

    def process_file(self, file_name):
        self._filename = file_name
        input_file = open(file_name, &#39;r&#39;)
        # Parse all the lines
        for line in input_file:
            self.ProcessLine(line)
            if self.root is not None:
                self.display()
        input_file.close()

    def write_as_dynamic_gexf(self, filename, mode = &#34;Dot&#34;):
        if not GEXF_INSTALLED:
            print(&#39;Gexf not installed. Exiting.&#39;)
            return
        if mode == &#39;Dot&#39;:
            try:
                gexf = Gexf(&#34;Mike O&#39;Sullivan&#34;, &#34;Dynamic graph file&#34;)
                graph = gexf.addGraph(&#34;directed&#34;, &#34;dynamic&#34;, &#34;Dynamic graph&#34;)
                objAtt = graph.addNodeAttribute(&#34;obj&#34;, &#34;0.0&#34;, &#34;float&#34;)
                currAtt = graph.addNodeAttribute(&#34;current&#34;, &#34;1.0&#34;,
                                                 &#34;integer&#34;, &#34;dynamic&#34;)
                node_names = self.get_node_list()
                for name in node_names:
                    node = self.get_node(name)
                    if node.get(&#34;step&#34;) is None:
                        raise Exception(&#34;Node without step in BBTree&#34;,
                                        &#34;node =&#34;, node)
                    curr_step = &#39;%s&#39; % node.get(&#34;step&#34;)
                    next_step = &#34;%s&#34; % (node.get(&#34;step&#34;) + 1)
                    n = graph.addNode(name, node.get_label(), start=curr_step)
                    if node.get(&#34;obj&#34;) is None:
                        raise Exception(&#34;Node without objective in BBTree&#34;,
                                        &#34;node =&#34;, node)
                    n.addAttribute(objAtt, &#34;%s&#34; % node.get(&#34;obj&#34;))
                    n.addAttribute(currAtt, &#34;1&#34;, start=curr_step, end=next_step)
                    n.addAttribute(currAtt, &#34;0&#34;, start=next_step)
                edge_names = self.get_edge_list()
                for i, (m_name, n_name) in enumerate(edge_names):
                    edge = self.get_edge(m_name, n_name)
                    if edge.get(&#34;step&#34;) is None:
                        raise Exception(&#34;Edge without step in BBTree&#34;,
                                        &#34;edge =&#34;, (m_name, n_name))
                    curr_step = &#34;%s&#34; % edge.get(&#34;step&#34;)
                    graph.addEdge(i, m_name, n_name, start=curr_step)
                output_file = open(filename + &#34;.gexf&#34;, &#34;w&#34;)
                gexf.write(output_file)
            except Exception as e:
                print(e)
                print(&#34;No .gexf file created&#34;)
        else:
            raise Exception(&#34;Only Dot mode supported in write_as_dynamic_gexf&#34;)

    def set_display_mode(self, mode):
        if mode is &#39;off&#39;:
            self.attr[&#39;display&#39;] = mode
        elif mode is &#39;matplotlib&#39;:
            if MATPLOTLIB_INSTALLED:
                self.attr[&#39;display&#39;] = &#39;matplotlib&#39;
            else:
                print(&#39;Matplotlib is not installed. Display is set to off.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif mode is &#39;PIL&#39;:
            if PIL_INSTALLED:
                self.attr[&#39;display&#39;] = &#39;PIL&#39;
            else:
                print(&#39;PIL is not installed. Display is set to off.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif mode is &#39;xdot&#39;:
            if XDOT_INSTALLED:
                self.attr[&#39;display&#39;] = &#39;xdot&#39;
            else:
                print(&#39;Xdot is not installed. Display is set to off.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif mode is &#39;file&#39;:
            self.attr[&#39;display&#39;] = &#39;file&#39;
        elif mode is &#39;matplotlib&#39;:
            self.attr[&#39;display&#39;] = &#39;matplotlib&#39;
        else:
            raise Exception(&#39;%s is not a valid display mode.&#39; %mode)

    def display(self, item = &#39;all&#39;, basename = &#39;graph&#39;, format=&#39;png&#39;,
                count=None, pause=False, wait_for_click=True):
        &#39;&#39;&#39;
        Displays/Saves images requested. BranchAndBound method calls this method
        to visualize the branch and bound tree.
        &#39;&#39;&#39;
        if self.attr[&#39;layout&#39;] != &#39;bak&#39;:
            if &#39;init_log_cond&#39; in self.root.attr:
                max_log_cond = 0
                for n in list(self.nodes.values()):
                    if &#39;init_log_cond&#39; in n.attr:
                        max_log_cond = max(n.attr[&#39;init_log_cond&#39;], max_log_cond)
                for n in list(self.nodes.values()):
                    if &#39;init_log_cond&#39; in n.attr:
                        log_begin = n.attr[&#39;init_log_cond&#39;]
                        log_end = n.attr[&#39;final_log_cond&#39;]
                        normalized_cond = (1-old_div(log_begin,max_log_cond))
                        color = str(hex(int(normalized_cond*256))[2:]) if normalized_cond &gt;= .0625 else &#39;0&#39; + str(hex(int(normalized_cond*256))[2:])
                        n.attr[&#39;label&#39;] = &#39;%.0f \n %.0f&#39; % (log_begin, log_end)
                        n.attr[&#39;color&#39;] = &#39;#&#39; + color*3
                        n.attr[&#39;fillcolor&#39;] = &#39;#&#39; + color*3
                        n.attr[&#39;style&#39;] = &#39;filled&#39;
                    else:
                        n.attr[&#39;label&#39;] = &#39; &#39;
            BinaryTree.display(self, pause = pause, wait_for_click = wait_for_click)
            return
        if self.attr[&#39;display&#39;] is &#39;off&#39;:
            return
        if self.attr[&#39;display&#39;] is &#39;matplotlib&#39;:
            gnuplot_script = None
            if item==&#39;all&#39;:
                self.display_all()
            elif item==&#39;tree&#39;:
                gnuplot_script = self.GenerateTreeImage()
            elif item==&#39;scatterplot&#39;:
                gnuplot_script = self.GenerateScatterplot()
            elif item==&#39;histogram&#39;:
                gnuplot_script = self.GenerateHistogram()
            elif item==&#39;incumbent&#39;:
                gnuplot_script = self.GenerateIncumbentPath()
            elif item==&#39;forecast&#39;:
                gnuplot_script = self.GenerateForecastImages()
            else:
                raise Exception(&#39;Unknown display() method argument %s&#39; %item)
            if gnuplot_script is not None:
                self.display_image(gnuplot_script)
            # clean auxilary files.
            histogram_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;histogram&#34;)]
            incumbent_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;incumbentpath&#34;)]
            scatterplot_files = [f for f in os.listdir(&#34;.&#34;)
                                 if f.startswith(&#34;scatterplot&#34;)]
            t_fathomed_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_fathomed&#34;)]
            t_infeasible_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_infeasible&#34;)]
            t_pregnant_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_pregnant&#34;)]
            t_integer_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;tree_integer&#34;)]
            t_branched_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;tree_branched&#34;)]
            bak_filelist = (histogram_files + incumbent_files +
                            scatterplot_files + t_fathomed_files +
                            t_integer_files + t_branched_files +
                            t_infeasible_files + t_pregnant_files)
            for f in bak_filelist:
                os.remove(f)
        elif self.attr[&#39;display&#39;] is &#39;xdot&#39;:
            if XDOT_INSTALLED:
                window = xdot.DotWindow()
                window.set_dotcode(self.to_string())
                window.connect(&#39;destroy&#39;, gtk.main_quit)
                gtk.main()
            else:
                print(&#39;Error: xdot not installed. Display disabled.&#39;)
                self.attr[&#39;display&#39;] = &#39;off&#39;
        elif self.attr[&#39;display&#39;] is &#39;file&#39;:
            if count is not None:
                basename = basename + &#39;_&#39; + str(count)
            if self.attr[&#39;layout&#39;] is &#39;dot2tex&#39;:
                if DOT2TEX_INSTALLED:
                    if format != &#39;pdf&#39; or format != &#39;ps&#39;:
                        print(&#34;Dot2tex only supports pdf and ps formats,&#34;+\
                            &#34;falling back to pdf&#34;)
                        format = &#39;pdf&#39;
                    self.set_layout(&#39;dot&#39;)
                    tex = dot2tex.dot2tex(self.to_string(), autosize=True,
                                          texmode = &#39;math&#39;,
                                          template = DOT2TEX_TEMPLATE)
                    f = open(basename+&#39;.tex&#39;, &#39;w&#39;)
                    f.write(tex)
                    f.close()
                    subprocess.call([&#39;latex&#39;, basename])
                    if format == &#39;ps&#39;:
                        subprocess.call([&#39;dvips&#39;, basename])
                    elif format == &#39;pdf&#39;:
                        subprocess.call([&#39;pdflatex&#39;, basename])
                    self.set_layout(&#39;dot2tex&#39;)
                    # clean auxilary files.
                    aux_filelist = [basename+&#39;.tex&#39;, basename+&#39;.log&#39;,
                                    basename+&#39;.dvi&#39;, basename+&#39;.aux&#39;]
                    for f in aux_filelist:
                        os.remove(f)
                else:
                    print(&#34;Dot2tex not installed, falling back to graphviz&#34;)
                    self.set_layout(&#39;dot&#39;)
                    self.write(basename+&#39;.&#39;+format, self.get_layout(), format)
            else:
                gnuplot_script = None
                if item==&#39;all&#39;:
                    self.display_all()
                elif item==&#39;tree&#39;:
                    gnuplot_script = self.GenerateTreeImage()
                elif item==&#39;scatterplot&#39;:
                    gnuplot_script = self.GenerateScatterplot()
                elif item==&#39;histogram&#39;:
                    gnuplot_script = self.GenerateHistogram()
                elif item==&#39;incumbent&#39;:
                    gnuplot_script = self.GenerateIncumbentPath()
                elif item==&#39;forecast&#39;:
                    gnuplot_script = self.GenerateForecastImages()
                else:
                    raise Exception(&#39;Unknown display() method argument %s&#39; %item)
                if gnuplot_script is not None:
                    self.write_image(gnuplot_script, basename+&#39;.&#39;+format)
                # clean auxilary files.
                histogram_files = [f for f in os.listdir(&#34;.&#34;)
                                   if f.startswith(&#34;histogram&#34;)]
                incumbent_files = [f for f in os.listdir(&#34;.&#34;)
                                   if f.startswith(&#34;incumbentpath&#34;)]
                scatterplot_files = [f for f in os.listdir(&#34;.&#34;)
                                     if f.startswith(&#34;scatterplot&#34;)]
                t_fathomed_files = [f for f in os.listdir(&#34;.&#34;)
                                    if f.startswith(&#34;tree_fathomed&#34;)]
                t_infeasible_files = [f for f in os.listdir(&#34;.&#34;)
                                      if f.startswith(&#34;tree_infeasible&#34;)]
                t_pregnant_files = [f for f in os.listdir(&#34;.&#34;)
                                    if f.startswith(&#34;tree_pregnant&#34;)]
                t_integer_files = [f for f in os.listdir(&#34;.&#34;)
                                   if f.startswith(&#34;tree_integer&#34;)]
                t_branched_files = [f for f in os.listdir(&#34;.&#34;)
                                    if f.startswith(&#34;tree_branched&#34;)]
                bak_filelist = (histogram_files + incumbent_files +
                                scatterplot_files + t_fathomed_files +
                                t_integer_files + t_branched_files +
                                t_infeasible_files + t_pregnant_files)
                for f in bak_filelist:
                    os.remove(f)
        else:
            raise Exception(&#39;Unknown display mode %s&#39; %self.attr[&#39;display&#39;])

    def display_all(self):
        &#39;&#39;&#39;
        Assumes all the images have the same size.
        &#39;&#39;&#39;
        print (&#39;This function is deprected and no longer functions&#39;)
        return

        # Old source, just in case
        # if not (MATPLOTLIB_INSTALLED and PIL_INSTALLED:
        #     print(&#39;Matplotlib or Pillow not installed. Display disabled&#39;)
        #     return
        # tree = self.GenerateTreeImage()
        # scatterplot = self.GenerateScatterplot()
        # histogram = self.GenerateHistogram()
        # incumbent = self.GenerateIncumbentPath()
        # if tree is not None:
        #     imTree = StringIO(tree)
        #     pTree = pygame.image.load(imTree, &#39;png&#39;)
        #     sTree = pTree.get_size()
        #     rTree = pygame.Rect(0,0,sTree[0],sTree[1])
        # if scatterplot is not None:
        #     imScatterplot = StringIO(scatterplot)
        #     pScatterplot = pygame.image.load(imScatterplot, &#39;png&#39;)
        #     sScatterplot = pScatterplot.get_size()
        #     rScatterplot = pygame.Rect(sTree[0],0,sScatterplot[0],
        #                                sScatterplot[1])
        # if histogram is not None:
        #     imHistogram = StringIO(histogram)
        #     pHistogram = pygame.image.load(imHistogram, &#39;png&#39;)
        #     sHistogram = pHistogram.get_size()
        #     rHistogram = pygame.Rect(0,sTree[1],sHistogram[0],sHistogram[1])
        # if incumbent is not None:
        #     imIncumbent = StringIO(incumbent)
        #     pIncumbent = pygame.image.load(imIncumbent, &#39;png&#39;)
        #     sIncumbent = pIncumbent.get_size()
        #     rIncumbent = pygame.Rect(sTree[0],sTree[1],sIncumbent[0],
        #                              sIncumbent[1])
        # screen = pygame.display.set_mode((sTree[0]+sTree[0], sTree[1]+sTree[1]))
        # if tree is not None:
        #     screen.blit(pTree, rTree)
        # if scatterplot is not None:
        #     screen.blit(pScatterplot, rScatterplot)
        # if histogram is not None:
        #     screen.blit(pHistogram, rHistogram)
        # if incumbent is not None:
        #     screen.blit(pIncumbent, rIncumbent)
        # pygame.display.flip()
        # if self._wait_for_keypress:
        #     pause = True
        #     print(&#34;Press any key to continue to next image (ESCAPE to disable pausing)&#34;)
        # else:
        #     pause = False
        # while pause:
        #     e = pygame.event.poll()
        #     if e.type == pygame.KEYDOWN:
        #         keystate = pygame.key.get_pressed()
        #         if keystate[pygame.K_ESCAPE] != 0:
        #             self._wait_for_keypress = False
        #         break
        #     if e.type == pygame.QUIT:
        #         pause = False
        #         pygame.display.quit()
        #         # sys.exit() exits the whole program and I (aykut) guess it is
        #         # not appropriate here.
        #         #sys.exit()

    def write_image(self, gnuplot_script, filename):
        if not (MATPLOTLIB_INSTALLED and PIL_INSTALLED):
            print(&#39;Either matplotlib or Pillow is not installed. Display disabled&#39;)
            return
        try:
            p = subprocess.run([&#39;gnuplot&#39;], capture_output = True,
                               input = bytearray(gnuplot_script, &#39;utf8&#39;))
        except OSError:
            print(&#39;&#39;&#39;Gnuplot executable not found.
Gnuplot must be installed and in your search path.
After installation, ensure that the PATH variable is properly set.&#39;&#39;&#39;)
            return
        p.check_returncode()

        if p.stderr:
            print(p.stderr)        

        if isinstance(filename, str):
            with open(filename, &#34;w+b&#34;) as f:
                f.write(p.stdout)
        else:
            filename.write(p.stdout)

    def display_image(self, gnuplot_script, pause = False, wait_for_click = True):

        if not (PIL_INSTALLED and MATPLOTLIB_INSTALLED):
            print(&#39;Warning: Either matplotlib or Pillow is not installed. Cannot display.&#39;)
            return
        
        tmp_fd, tmp_name = tempfile.mkstemp()
        tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
        self.write_image(gnuplot_script, tmp_file)
        tmp_file.close()
        im = PIL_Image.open(tmp_name)
        plt.figure(1)
        plt.clf()
        plt.axis(&#39;off&#39;)
        plt.imshow(im, interpolation=&#39;bilinear&#39; #resample=True
                   #extent = (0, 100, 0, 100)
        )
        if wait_for_click == True:
            plt.draw()
            try:
                if plt.waitforbuttonpress(timeout = 10000):
                    plt.close()
                    exit()
            except:
                exit()
        else:
            plt.show(block=pause)
        im.close()

    def set_label(self, label):
        self._label = label

    def set_logscaley(self, boolean):
        self._logscaley = boolean

    def set_fathom(self, boolean):
        self._fathom = boolean

    def set_edge_limit(self, limit):
        self._edge_limit = limit

    def set_sample_tree(self, number):
        self._sample_tree = number

    def AddOrUpdateNode(self, id, parent_id, branch_direction, status, lp_bound,
                        integer_infeasibility_count, integer_infeasibility_sum,
                        condition_begin = None, condition_end = None,
                        **attrs):
        &#39;&#39;&#39;
        This method designed to update nodes (in BAK) but we use it for
        updating/adding arcs. This is because of the tree data structure the
        authors adopted in BAK.
        We can divide these attributes such that some will belong to the edge
        parent_id-&gt;id and the others belong to the id node. The following shows
        whether the attribute belongs to edge or node.
        branch direction -&gt; edge
        status -&gt; node
        lp_bound -&gt; node
        integer_infeasibility_count -&gt; node
        integer_infeasibility_sum -&gt; node
        parent_id -&gt; node
        &#39;&#39;&#39;
        if (condition_begin is not None) and (condition_end is not None):
            #Figure out the color
            attrs[&#39;init_log_cond&#39;] = math.log(condition_begin, 10)
            attrs[&#39;final_log_cond&#39;] = math.log(condition_end, 10)
        if id in self.neighbors:
            # node already exists, update attributes
            self.set_node_attr(id, &#39;status&#39;, status)
            self.set_node_attr(id, &#39;lp_bound&#39;, lp_bound)
            self.set_node_attr(id, &#39;integer_infeasibility_count&#39;,
                               integer_infeasibility_count)
            self.set_node_attr(id, &#39;integer_infeasibility_sum&#39;,
                               integer_infeasibility_sum)
            if (condition_begin is not None) and (condition_end is not None):
                self.set_node_attr(id, &#39;init_log_cond&#39;,
                                   math.log(condition_begin, 10))
                self.set_node_attr(id, &#39;final_log_cond&#39;,
                                   math.log(condition_end, 10))
        elif self.root is None:
            self.add_root(id, status = status, lp_bound = lp_bound,
                          integer_infeasibility_count = integer_infeasibility_count,
                          integer_infeasibility_sum = integer_infeasibility_sum,
                          subtree_root = None, **attrs)
        elif parent_id is not None:
            if branch_direction == &#39;L&#39;:
                self.add_left_child(id, parent_id, status = status,
                    lp_bound = lp_bound,
                    integer_infeasibility_count = integer_infeasibility_count,
                    integer_infeasibility_sum = integer_infeasibility_sum,
                    subtree_root = None, **attrs)
            elif branch_direction == &#39;R&#39;:
                self.add_right_child(id, parent_id, status = status,
                    lp_bound = lp_bound,
                    integer_infeasibility_count = integer_infeasibility_count,
                    integer_infeasibility_sum = integer_infeasibility_sum,
                    subtree_root = None, **attrs)
        else:
            print(&#39;this should not happen.&#39;)
            raise Exception()
        if lp_bound is not None:
            self.UpdateObjectiveValueLimits(lp_bound)
            # Set optimization sense if not yet set
            if self._optimization_sense is None:
                if lp_bound &lt; self.root.get_attr(&#39;lp_bound&#39;):
                    self._optimization_sense = &#39;max&#39;
                elif lp_bound &gt; self.root.get_attr(&#39;lp_bound&#39;):
                    self._optimization_sense = &#39;min&#39;
            if self._optimization_sense == &#39;min&#39; and lp_bound &lt; self.root.get_attr(&#39;lp_bound&#39;):
                print(&#34;Switching guess about objective sense to maximization based on bound change&#34;)
                self._optimization_sense = &#39;max&#39;
            if self._optimization_sense == &#39;max&#39; and lp_bound &gt; self.root.get_attr(&#39;lp_bound&#39;):
                print(&#34;Switching guess about objective sense to minimization based on bound change&#34;)
                self._optimization_sense = &#39;max&#39;
        if integer_infeasibility_sum is not None:
            if (self._max_integer_infeasibility_sum is None or
                integer_infeasibility_sum &gt;
                self._max_integer_infeasibility_sum):
                self._max_integer_infeasibility_sum = integer_infeasibility_sum

    def IsBetterThan(self, value1, value2):
        &#34;&#34;&#34;
        Returns True if value1 is better than value2 as an objective value.
        This depends on the optimization sense of the instance.
        Args:
          value1: Float.
          value2: Float.
        Returns:
          True if value1 is better than value2 as an objective value.
        &#34;&#34;&#34;
        if self._optimization_sense is None:
            print(&#34;Optimization sense is not set, assuming sense is miniminzation&#34;)
            self._optimization_sense = &#39;min&#39;
        if self._optimization_sense == &#39;min&#39;:
            return value1 &lt; value2
        else:
            return value1 &gt; value2

    def IsBetterThanIncumbent(self, value):
        &#34;&#34;&#34;
        Returns True if the passed value is better than current incumbent.
        Args:
          value: Float to use for comparison.
        Returns:
          True if the passed value is better than the current incumbent.
          &#39;Better&#39; is determined by the sense of optimization.
        &#34;&#34;&#34;
        if self._incumbent_value is None:
            return True
        else:
            return self.IsBetterThan(value, self._incumbent_value)

    def UpdateObjectiveValueLimits(self, value):
        &#34;&#34;&#34;Updates the min and max objective values if appropriate.
        Args:
          value: Float objective value.
        &#34;&#34;&#34;
        if self._max_objective_value is None:
            self._max_objective_value = value
            self._min_objective_value = value
        else:
            if value &gt; self._max_objective_value:
                self._max_objective_value = value
            if value &lt; self._min_objective_value:
                self._min_objective_value = value

    def AddProgressMeasures(self):
        # No progress measures if there is no incumbent yet
        if self._incumbent_value is None:
            return
        # Store sum-of-subtree-gaps
        # We need to traverse all nodes unfortunately
        # TODO(bhunsaker): check whether we can just traverse active nodes
        active_node_count = 0
        subtree_bounds = {}
        new_integer_ssg = 0  # Only needed if this is a new integer solution
        for node_id in self.get_node_list():
            status = self.get_node_attr(node_id, &#39;status&#39;)
            if status == &#39;candidate&#39; or status == &#39;pregnant&#39;:
                lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
                subtree_root = self.get_node_attr(node_id, &#39;subtree_root&#39;)
                # Optional check for fathomed nodes.
                if (self._fathom and
                    not self.IsBetterThanIncumbent(lp_bound)):
                    continue
                active_node_count += 1
                if (subtree_root not in subtree_bounds or
                    self.IsBetterThan(lp_bound, subtree_bounds[subtree_root])):
                    subtree_bounds[subtree_root] = lp_bound
                if self._new_integer_solution:
                    self.set_node_attr(node_id, &#39;subtree_root&#39;, id)
                    new_integer_ssg += abs(self._incumbent_value - lp_bound)
        # If we have a new integer solution, we need to compute what
        # the measure would be with the previous integer solution for
        # scaling purposes.
        if (self._new_integer_solution and
            self._previous_incumbent_value is not None):
            reference_value = self._previous_incumbent_value
        else:
            reference_value = self._incumbent_value
        sum_subtree_gaps = 0
        for lp_bound in list(subtree_bounds.values()):
            sum_subtree_gaps += abs(reference_value - lp_bound)
        # Start a new sequence if a new integer solution was just found
        if self._new_integer_solution:
            if new_integer_ssg &gt;= 1e-6:
                scale_factor = (old_div(float(sum_subtree_gaps),
                                float(new_integer_ssg)))
            else:
                scale_factor = 1.0
            self._sum_subtree_gaps_forecaster.StartNewSequence(scale_factor)
            # sum_subtree_gaps was based on the previous integer solution;
            # update it now
            sum_subtree_gaps = new_integer_ssg
        self._sum_subtree_gaps_forecaster.AddMeasure(self._time,
                                                     sum_subtree_gaps,
                                                     active_node_count,
                                                     len(self.get_node_list()))
        # Add objective gap measure.  Note that this relies on the
        # active_node_count computed above.
        if self._new_integer_solution:
            self._objective_gap_forecaster.StartNewSequence(1.0)
        if self._optimization_sense == &#39;min&#39;:
            obj_gap = self._incumbent_value - self._min_objective_value
        else:
            obj_gap = self._max_objective_value - self._incumbent_value
        self._objective_gap_forecaster.AddMeasure(self._time, obj_gap,
                                                  active_node_count,
                                                  len(self.get_node_list()))

    def GetImageCounterString(self):
        &#34;&#34;&#34;
        Returns a string with the image counter.
        &#34;&#34;&#34;
        return &#39;%03d&#39; % self._image_counter

    def WriteHistogramScript(self, num_bins, bin_width, max_bin_count,
                                 lp_bound, data_filename, output_file):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate a histogram image.
        Args:
          num_bins: Integer number of bins for the histogram.
          bin_width: Float width of the bins in terms of objective values.
          max_bin_count: Integer number of the highest bin count.
          lp_bound: Float value of the current LP bound.
          data_filename: String name of the file; used for display purposes.
        &#34;&#34;&#34;
        # TODO(bhunsaker): add checks for bin_width zero
        if self._incumbent_value is not None:
            incumbent_bin = 1 + ((self._incumbent_value -
                                  self._histogram_lower_bound) // bin_width)
            incumbent_x_coord = 0.5 + (old_div((self._incumbent_value -
                                        self._histogram_lower_bound),
                                       bin_width))
        lp_bound_bin = 1 + ((lp_bound - self._histogram_lower_bound) //
                            bin_width)
        lp_bound_x_coord = 0.5 + (old_div((lp_bound - self._histogram_lower_bound),
                                  bin_width))
        # TODO(bhunsaker): Ask Osman about adjust_xcoord option, which appears
        #    to put the vertical lines at the edge of bins rather than the
        #    true location.
        # Output the Gnuplot script to a file.
        script = &#34;&#34;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the scatter plot.
        index_string = self.GetImageCounterString()
        output_filename = &#34;histogram.&#34;+index_string+&#34;.png&#34;
        if output_file:
            script += &#39;set output &#34;%s&#34;\n&#39; % output_filename
        if self._filename is None:
            script += &#39;set title &#34;Histogram of LP Bounds&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Histogram of LP Bounds: %s, %s, %.2fs&#34;\n&#39;
                       % (self._filename, self._label, self._time))
        script += &#39;set xlabel &#34;obj. value&#34;\n&#39;
        script += &#39;set ylabel &#34;number of nodes&#34;\n&#39;
        if self._logscaley:
            script += &#39;set logscale y\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set tics scale 0.001\n&#39;

        script += &#39;set xrange [0:%d+1]\n&#39; % num_bins
        if self._logscaley:
            script += &#39;set yrange [1:%d*1.2]\n&#39; % max_bin_count
        else:
            script += &#39;set yrange [0:%d*1.2]\n&#39; % max_bin_count
        script += &#39;set xtics rotate by 90\n&#39;
        # Mark tics for each bin.
        script += &#39;set xtics (&#39;
        # TODO(bhunsaker): Consider putting this in a loop.
        x_values = [&#39;&#34;%0.2f&#34; %0.2f&#39; %
                    (self._histogram_lower_bound + i * bin_width, i + 0.5)
                    for i in range(num_bins + 1)]
        script += &#39;, &#39;.join(x_values) + &#39;)\n&#39;
        # Plot LP bound and incumbent tics.
        script += &#39;set x2tics (&#39;
        script += &#39;&#34;%0.2f&#34; %d&#39; % (lp_bound, lp_bound_bin)
        if self._incumbent_value is not None:
            script += &#39;, &#34;%0.2f&#34;%d)\n&#39; % (self._incumbent_value,
                                                  incumbent_bin)
        else:
            script += &#39;)\n&#39;
        plot_parts = []
        # Plot the data points.
        plot_parts.append(&#39;\&#39;%s\&#39; with boxes fill solid 0.2&#39; % data_filename)
        # Draw the vertical lp_bound and incumbent lines.
        script += &#39;set parametric\n&#39;
        script += &#39;set trange [0:%d*1.5]\n&#39; % max_bin_count
        plot_parts.append(&#39;%0.2f,t linetype 2&#39; % lp_bound_x_coord)
        if self._incumbent_value is not None:
            plot_parts.append(&#39;%0.2f,t linetype 5&#39; % incumbent_x_coord)
        script += &#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts)
        script += &#39;unset parametric\n&#39;
        script += &#39;show output\n&#39;
        return script

    def AdjustHistogramEndBins(self, objective_list, num_bins, bin_width,
                               bin_counts, bin_centers, bin_widths):
        &#34;&#34;&#34;
        Adjusts the two end bins if necessary to make them narrower.
        The two end bins may need to be narrower than the other bins so that
        they do not go past the current incumbent value on one end and the
        current lp bound on the other.  So that the histogram is still correct
        in areas, the height of these bins needs to be adjusted so that the
        area does not change.

        Note that there is likely to be some bias toward taller bins on
        the ends since they always have a point at one end of their width.  It
        may be more accurate visually to ignore or discount that one point when
        determining the bin height, but that is not currently done.

        Args:
          objective_list: List of float objective values.
          num_bins: Integer number of bins.
          bin_width: Float standard width of bins in terms of objective values.
          bin_counts: List of integer counts for each bin.
          bin_centers: List of float coordinates for the center of each bin.
          bin_widths: List of float widths for bins, allowing for individualized
            widths.
        &#34;&#34;&#34;
        if self._optimization_sense == &#39;min&#39;:
            lp_bound = min(objective_list)
            lower_bound = lp_bound
            if self._incumbent_value is not None:
                upper_bound = self._incumbent_value
            else:
                upper_bound = self._histogram_upper_bound
        else:
            lp_bound = max(objective_list)
            upper_bound = lp_bound
            if self._incumbent_value is not None:
                lower_bound = self._incumbent_value
            else:
                lower_bound = self._histogram_lower_bound
        # The end bins may have unusual centers and widths
        highest_nonempty_bin = int((upper_bound -
                                    self._histogram_lower_bound) // bin_width)
        if (highest_nonempty_bin &lt; num_bins and
            bin_counts[highest_nonempty_bin] &gt; 0):
            highest_x_coord = 0.5 + (old_div((upper_bound -
                                      self._histogram_lower_bound), bin_width))
            highest_nonempty_bin_width, unused_int = math.modf(0.5 +
                                                               highest_x_coord)
            if highest_nonempty_bin_width == 0.0:
                highest_nonempty_bin_width = 1.0
            bin_widths[highest_nonempty_bin] = highest_nonempty_bin_width
            bin_centers[highest_nonempty_bin] = highest_x_coord - (
                old_div(highest_nonempty_bin_width, 2))
            # Scale the height appropriately
            bin_counts[highest_nonempty_bin] /= bin_widths[highest_nonempty_bin]
        lowest_nonempty_bin = int((lower_bound -
                                   self._histogram_lower_bound) // bin_width)
        if bin_counts[lowest_nonempty_bin] &gt; 0:
            lowest_x_coord = 0.5 + (old_div((lower_bound -
                                     self._histogram_lower_bound), bin_width))
            lowest_nonempty_bin_excess, unused_int = math.modf(0.5 +
                                                               lowest_x_coord)
            bin_widths[lowest_nonempty_bin] = 1.0 - lowest_nonempty_bin_excess
            bin_centers[lowest_nonempty_bin] = (
                lowest_x_coord + old_div(bin_widths[lowest_nonempty_bin], 2))
            # Scale the height appropriately
            bin_counts[lowest_nonempty_bin] /= bin_widths[lowest_nonempty_bin]

    def GenerateHistogram(self, output_file = False):
        &#34;&#34;&#34;
        Generate files necessary for a histogram image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        Args:
          time: Float number of seconds since the start of optimization.
        &#34;&#34;&#34;
        num_bins = 20
        # Compute the bin width and counts.
        objective_list = []
        for n in self.get_node_list():
            if (self.get_node_attr(n,&#39;status&#39;) == &#39;candidate&#39; or
                self.get_node_attr(n,&#39;status&#39;) == &#39;pregnant&#39;):
                lp_bound = self.get_node_attr(n,&#39;lp_bound&#39;)
                if not self.IsBetterThanIncumbent(lp_bound):
                    continue
                objective_list.append(lp_bound)
        # TODO(aykut) added the following check, we need it since we generate
        # histograms real time
        # we can not generate histogram if we do not have upperl and lower
        #bounds
        if len(objective_list)==0 or self._incumbent_value is None:
            return None
        # The first time we create a histogram, set bounds for objective
        # values.
        # TODO(bhunsaker): Consider bounds; talk to Osman.
        if self._histogram_lower_bound is None:
            if self._optimization_sense == &#39;min&#39;:
                self._histogram_lower_bound = min(objective_list)
                if self._incumbent_value is not None:
                    self._histogram_upper_bound = self._incumbent_value
                else:
                    self._histogram_upper_bound = max(objective_list)
            else:
                self._histogram_upper_bound = max(objective_list)
                if self._incumbent_value is not None:
                    self._histogram_lower_bound = self._incumbent_value
                else:
                    self._histogram_lower_bound = min(objective_list)
        bin_width = old_div((self._histogram_upper_bound -
                     self._histogram_lower_bound), float(num_bins))
        bin_counts = [0.0 for i in range(num_bins)]
        for value in objective_list:
            bin = int(math.floor(old_div((value - self._histogram_lower_bound),
                                 bin_width)))
            # Special case for the largest value.
            if (value &gt;= self._histogram_upper_bound and
                value &lt; self._histogram_upper_bound + 1e-6):
                bin = num_bins - 1
            if bin &lt; 0:
                return
            assert bin &lt; num_bins, &#39;%d (%f) !&lt; %d (%f)&#39; % (
                bin, value, num_bins, self._histogram_upper_bound)
            bin_counts[bin] += 1
        max_bin_count = max(bin_counts)
        bin_centers = [i + 1.0 for i in range(len(bin_counts))]
        bin_widths = [1.0 for i in range(len(bin_counts))]
        self.AdjustHistogramEndBins(objective_list, num_bins, bin_width,
                                    bin_counts, bin_centers, bin_widths)
        if self._optimization_sense == &#39;min&#39;:
            lp_bound = min(objective_list)
        else:
            lp_bound = max(objective_list)
        # Output the bin data to a file.
        index_string = self.GetImageCounterString()
        data_filename = &#39;histogram%s.dat&#39; % index_string
        data_file = open(data_filename, &#39;w&#39;)
        for index in range(len(bin_counts)):
            data_file.write(&#39;%f %f %f\n&#39; % (bin_centers[index],
                                            bin_counts[index],
                                            bin_widths[index]))
        data_file.close()
        histogram_script = self.WriteHistogramScript(num_bins, bin_width,
                           max_bin_count, lp_bound, data_filename, output_file)
        # TODO(bhunsaker): Temporary hack
        #   This allows the bounds to be reset until an incumbent is found.
        if self._incumbent_value is None:
            self._histogram_lower_bound = None
            self._histogram_upper_bound = None
        return histogram_script

    def GetImageObjectiveBounds(self, min_value, max_value):
        &#34;&#34;&#34;
        Return min and max bounds to be used for images.
        Images should use bounds that are slightly wider than observed
        objective values.  Also, the special case of a single value must be
        handled.
        Args:
          min_value: Float minimum objective value.
          max_value: Float maximum objective value.
        Returns:
          A tuple of two float values (lower_bound, upper_bound).
        &#34;&#34;&#34;
        obj_range = max_value - min_value
        if obj_range &gt; 0:
            image_max_obj = max_value + 0.01 * obj_range
            image_min_obj = min_value - 0.01 * obj_range
        else:
            if max_value &gt;= 0:
                image_max_obj = 1.01 * max_value
            else:
                image_max_obj = 0.99 * max_value
            if min_value &gt;= 0:
                image_min_obj = 0.99 * min_value
            else:
                image_min_obj = 1.01 * min_value
        return (image_min_obj, image_max_obj)

    def WriteScatterplotScript(self, data_filename, output_file):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate a scatterplot image.
        Args:
          data_filename: String name of the file; used for display purposes.
        &#34;&#34;&#34;
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._scatterplot_lower_bound, self._scatterplot_upper_bound)
        index_string = self.GetImageCounterString()
        output_filename = &#34;scatterplot.&#34;+index_string+&#34;.png&#34;
        script = &#34;&#34;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the scatter plot.
        if output_file:
            script += &#39;set output &#34;%s&#34;\n&#39; % output_filename
        if self._filename is None:
            script += &#39;set title &#34;Scatterplot&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Scatterplot: %s, %s, %ds&#34;\n&#39; % (
                    self._filename, self._label, int(self._time)))
        script += &#39;set pointsize 0.8\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
        script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
        script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                          self._max_integer_infeasibility_sum)
        script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                          image_max_obj))
        plot_parts = []
        # Plot the data points.
        plot_parts.append(&#39;\&#39;%s\&#39; with points pointtype 2 linetype 1&#39; %
                          data_filename)
        # Also plot the incumbent line.
        if self._incumbent_value is not None:
            plot_parts.append(&#39;%0.6f linetype 2 linewidth 0.5&#39; %
                              self._incumbent_value)
        # Plot the incumbent&#39;s parent if it&#39;s available.
        if self._incumbent_parent is not None:
            #incumbent_parent = self.get_node(self._incumbent_parent)
            plot_parts.append(&#39;&#34;&lt; echo %0.6f %0.6f&#34; &#39;
                              &#39;with points pointtype 9 pointsize 1.2&#39; %
                              (self.get_node_attr(self._incumbent_parent,
                                                  &#39;integer_infeasibility_sum&#39;),
                               self.get_node_attr(self._incumbent_parent,
                                                  &#39;lp_bound&#39;)))
        script += &#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts)
        script += &#39;show output\n&#39;
        return script

    def GenerateScatterplot(self, output_file = False):
        &#34;&#34;&#34;
        Generate files necessary for a scatterplot image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        Args:
            output_file: if not given the gnuplot image will not be written
        to disk but returned (to be displayed in matplotlib window)
        &#34;&#34;&#34;
        # Output data points.
        index_string = self.GetImageCounterString()
        data_filename = &#39;scatterplot%s.dat&#39; % index_string
        data_file = open(data_filename, &#39;w&#39;)
        if self._scatterplot_lower_bound is None:
            bounds = []
        # Write objective values and integer infeasibility sum information
        # for candidate and pregnant nodes.
        for node in self.get_node_list():
            status = self.get_node_attr(node, &#39;status&#39;)
            lp_bound = self.get_node_attr(node,&#39;lp_bound&#39;)
            if status == &#39;candidate&#39; or status == &#39;pregnant&#39;:
                # Optional check for fathomed nodes.
                if (self._fathom and
                    not self.IsBetterThanIncumbent(lp_bound)):
                    continue
                data_file.write(&#39;%0.6f %0.6f\n&#39; % (
                        self.get_node_attr(node, &#39;integer_infeasibility_sum&#39;),
                        lp_bound))
                # Set the image objective bounds the first image.
                if self._scatterplot_lower_bound is None:
                    bounds.append(lp_bound)
        data_file.close()
        if self._scatterplot_lower_bound is None:
            if len(bounds) &lt;= 1:
                return None
            self._scatterplot_lower_bound = min(bounds)
            self._scatterplot_upper_bound = max(bounds)
            # The incumbent overrides a bound if present.
            if self._incumbent_value is not None:
                if self._optimization_sense == &#39;min&#39;:
                    self._scatterplot_upper_bound = self._incumbent_value
                else:
                    self._scatterplot_lower_bound = self._incumbent_value
        scatterplot_script = self.WriteScatterplotScript(data_filename,
                                                         output_file)
        return scatterplot_script

    def WriteIncumbentPathScript(self, data_filename):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate an incumbent path image.
        Args:
          data_filename: String name of the file; used for display purposes.
        &#34;&#34;&#34;
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._scatterplot_lower_bound, self._scatterplot_upper_bound)
        script = &#39;&#39;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;
        if self._filename is None:
            script += &#39;set title &#34;Incumbent path&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Incumbent path (%s %.2fs %s)&#34;\n&#39; % (
                    self._filename, self._time, self._label))
        script += &#39;set pointsize 0.8\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
        script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
        script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                          self._max_integer_infeasibility_sum)
        script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                          image_max_obj))
        # Plot the data points and connecting lines.
        script += (&#39;plot \&#39;%s\&#39; with points pointtype 2, &#39;
                          &#39;\&#39;%s\&#39; with lines linetype 2\n&#39; %
                          (data_filename, data_filename))
        script += &#39;show output\n&#39;
        return script

    def WriteAllIncumbentPathsScript(self):
        &#34;&#34;&#34;
        Return a Gnuplot script string to generate an incumbent path image.
        Args:
          data_filenames: List of string names of files.
        &#34;&#34;&#34;
        data_filenames = self._incumbent_path_datafiles
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._scatterplot_lower_bound, self._scatterplot_upper_bound)
        script = &#39;&#39;
        # Set terminal for the output files.
        script += &#39;set terminal png notransparent size 480,360\n\n&#39;

        # Make settings for the scatter plot.
        if self._filename is None:
            script += &#39;set title &#34;Incumbent paths&#34;\n&#39;
        else:
            script += (&#39;set title &#34;Incumbent paths (%s %.2fs %s)&#34;\n&#39; % (
                    self._filename, self._time, self._label))
        script += &#39;set pointsize 0.8\n&#39;
        script += &#39;set nokey\n&#39;
        script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
        script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
        script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                          self._max_integer_infeasibility_sum)
        script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                          image_max_obj))
        # Plot the data points and connecting lines.
        command_list = []
        for filename in data_filenames:
            command_list.append(&#39;\&#39;%s\&#39; with points pointtype 2, &#39;
                                &#39;\&#39;%s\&#39; with lines linetype 2&#39; %
                                (filename, filename))
        script += &#39;plot %s\n&#39; % &#39;,&#39;.join(command_list)
        script += &#39;show output\n&#39;
        return script

    def GenerateIncumbentPath(self):
        &#34;&#34;&#34;
        Generate files necessary for an incumbent scatterplot path image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        &#34;&#34;&#34;
        if self._incumbent_parent is None:
            return
        if self._scatterplot_lower_bound is None:
            return
        if self._scatterplot_upper_bound is None:
            return
        index_string = self.GetImageCounterString()
        # Output data points.
        data_filename = &#39;incumbentpath%s.dat&#39; % index_string
        data_file = open(data_filename, &#39;w&#39;)
        # Write objective values and integer infeasibility sum information
        # for ancestor nodes.
        data_file.write(&#39;0 %0.6f\n&#39; % self._incumbent_value)
        parent = self._incumbent_parent
        # TODO(bhunsaker): I think the following assumes a unique value for the
        #   parent of the root.
        while parent != None:
            data_file.write(&#39;%0.6f %0.6f\n&#39;
                            % (self.get_node_attr(parent,
                               &#39;integer_infeasibility_sum&#39;),
                             self.get_node_attr(parent, &#39;lp_bound&#39;)))
            parent = self.get_node_attr(parent, &#39;parent&#39;)
        data_file.close()
        self._incumbent_path_datafiles.append(data_filename)
        # Output the Gnuplot script to a file.
        path_script = self.WriteIncumbentPathScript(data_filename)
        return path_script

    def GenerateAllIncumbentPaths(self):
        &#34;&#34;&#34;
        Generate file for a path image with all incumbent paths.
        Data files were previously generated for each incumbent.  This re-uses
        those files.
        &#34;&#34;&#34;
        all_path_script = self.WriteAllIncumbentPathsScript()

    def WriteTreeScript(self, additional_lines = None):
        &#34;&#34;&#34;
        Write a Gnuplot script file to generate a tree image.
        Args:
          additional_lines: String with additional lines to be added to the
            script file.
        &#34;&#34;&#34;
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._min_objective_value, self._max_objective_value)
        data = &#39;&#39;
        data += &#39;set terminal png notransparent size 480,360\n&#39;
        data += &#39;set output &#34;%s&#34;\n&#39; % output_file
        data += &#39;set nokey\n&#39;
        data += &#39;set autoscale\n&#39;
        data += &#39;set tics scale 0.001\n&#39;
        data += &#39;set pointsize 0.5\n&#39;
        data += &#39;set xrange [-0.1:1.1]\n&#39;
        data += &#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_max_obj,
                                                          image_min_obj)
        data += &#39;set format x &#34;&#34;\n&#39;
        data += &#39;set ylabel &#34;obj. value&#34;\n&#39;
        if self._filename is None:
            data += &#39;set title &#34;B&amp;B tree&#34;\n&#39;
        else:
            data += &#39;set title &#34;B&amp;B tree (%s %.2fs %s)&#34;\n\n&#39; % (
                self._filename, self._time, self._label)
        for line in additional_lines:
            data += line
        return data

    def GetTreeFixedHorizontalPositions(self):
        &#34;&#34;&#34;
        Returns horizontal positions for all nodes based on fixed positions.
        Returns:
          Dictionary of float horizontal positions, keyed by node id.
        &#34;&#34;&#34;
        # Statistics needed for horizontal positions.
        horizontal_lower_bound = dict.fromkeys(self.get_node_list(), 0.0)
        horizontal_upper_bound = dict.fromkeys(self.get_node_list(), 1.0)
        horizontal_positions = dict.fromkeys(self.get_node_list())
        horizontal_positions[self.root.name] = 0.5
        # sort node list
        node_id_list = sorted(self.get_node_list())
        node_id_list_int = list(int(n) for n in node_id_list)
        node_id_list_int = sorted(node_id_list_int)
        node_id_list = list(str(n) for n in node_id_list_int)
        for node_id in node_id_list:
            if node_id == self.root.name:
                continue
            parent_id = self.get_node_attr(node_id, &#39;parent&#39;)
            branch_direction = self.get_node_attr(node_id, &#39;direction&#39;)
            if branch_direction == &#39;R&#39;:
                horizontal_lower_bound[node_id] = horizontal_positions[
                    parent_id]
                horizontal_upper_bound[node_id] = horizontal_upper_bound[
                    parent_id]
            elif branch_direction == &#39;L&#39;:
                horizontal_lower_bound[node_id] = horizontal_lower_bound[
                    parent_id]
                horizontal_upper_bound[node_id] = horizontal_positions[
                    parent_id]
            else:
                print(&#39;Error: node %s has unsupported branching direction.&#39;\
                    %node_id)
                print(&#39;Fixed-position tree images only support L and R &#39;)
                print(&#39;branching.&#39;)
                sys.exit(1)
            horizontal_positions[node_id] = old_div((
                horizontal_upper_bound[node_id] +
                horizontal_lower_bound[node_id]), 2)
        return horizontal_positions

    def GetTreeHorizontalPositions(self):
        &#34;&#34;&#34;
        Returns horizontal positions for all nodes.
        Each node is given equal horizontal space.
        Returns:
          Dictionary of float horizontal positions, keyed by node id.
        &#34;&#34;&#34;
        # Statistics needed for horizontal positions.
        number_descendants = dict.fromkeys(self.get_node_list(), 1)
        # number_descendants includes the key node itself
        horizontal_lower_bound = dict.fromkeys(self.get_node_list(), 0.0)
        horizontal_upper_bound = dict.fromkeys(self.get_node_list(), 1.0)
        horizontal_positions = dict.fromkeys(self.get_node_list())
        visited = dict.fromkeys(self.get_node_list(), False)
        # Count the number of descendants for each node.
        # Do a post-order traversal of the tree.
        node_stack = []
        node_stack.append(self.root.name)
        while node_stack:
            current_node = node_stack[len(node_stack) - 1]
            lchild = self.get_left_child(current_node)
            rchild = self.get_right_child(current_node)
            is_node_added = False
            # Add the next unvisited child to the stack
            if lchild is not None and not visited[quote(lchild)]:
                node_stack.append(lchild)
                is_node_added = True
            if (rchild is not None and not visited[quote(rchild)] and
                is_node_added==False):
                node_stack.append(rchild)
                is_node_added = True
            # If all childs visited, then update number_descendants
            if not is_node_added:
                if lchild is not None:
                    number_descendants[quote(current_node)] += (
                                number_descendants[quote(lchild)])
                if rchild is not None:
                    number_descendants[quote(current_node)] += (
                                number_descendants[quote(rchild)])
                visited[quote(current_node)] = True
                del node_stack[len(node_stack) - 1]
        # Traverse the tree and set horizontal positions.
        # Do a pre-order traversal of the tree.
        node_stack = []
        node_stack.append(self.root.name)
        horizontal_lower_bound[self.root.name] = 0.0
        horizontal_upper_bound[self.root.name] = 1.0
        while node_stack:
            node = node_stack.pop()
            lchild = self.get_left_child(node)
            rchild = self.get_right_child(node)
            direction = None
            number_of_children = 0
            children_list = []
            # Place all children on the stack
            if lchild is not None:
                node_stack.append(lchild)
                number_of_children += 1
                direction = &#39;L&#39;
                children_list.append(lchild)
            if rchild is not None:
                node_stack.append(rchild)
                number_of_children += 1
                direction = &#39;R&#39;
                children_list.append(rchild)
            # Convenience variables
            current_lower_bound = horizontal_lower_bound[quote(node)]
            current_range = (horizontal_upper_bound[quote(node)] -
                             horizontal_lower_bound[quote(node)])
            total_descendants = number_descendants[quote(node)]
            sorted_child_labels = sorted(children_list)
            # Determine where to place this node with respect to its children.
            # Put the node in the center, or have more children on the left.
            before_index = int(math.ceil(old_div(number_of_children,2.0)))
            # Exception with a single node that is &#39;L&#39;
            if number_of_children == 1:
                if direction != &#39;L&#39;:
                    before_index = 0
            cumulative_descendants = 0
            for i, label in enumerate(sorted_child_labels):
                if before_index == i:
                    # Determine the relative position for the current node
                    relative_position = old_div((cumulative_descendants + 0.5), (
                        total_descendants))
                    cumulative_descendants += 1
                # Set bounds for this child
                horizontal_lower_bound[quote(label)] = (
                    current_lower_bound + float(cumulative_descendants) /
                    total_descendants * current_range)
                # Increment cumulative_descendants, which also lets us compute
                # the upper bound.
                cumulative_descendants += number_descendants[quote(label)]
                horizontal_upper_bound[quote(label)] = (
                    current_lower_bound + float(cumulative_descendants) /
                    total_descendants * current_range)
            # Catch the case that the node comes after all its children.
            # This must also work for the case that this is the only node.
            if before_index == len(sorted_child_labels):
                relative_position = old_div((cumulative_descendants + 0.5), (
                    total_descendants))
            # Finally set the position for the current node
            horizontal_positions[quote(node)] = (
                horizontal_lower_bound[quote(node)] + relative_position * (
                    horizontal_upper_bound[quote(node)] -
                    horizontal_lower_bound[quote(node)]))
        return horizontal_positions

    def WriteDataFileFromList(self, filename, data_list):
        &#34;&#34;&#34;
        Write a list of string data to a file with one entry per line.
        Args:
          filename: String filename to open.
          data_list: List of string values to write.
        &#34;&#34;&#34;
        outfile = open(filename, &#39;w&#39;)
        for line in data_list:
            outfile.write(line)
        outfile.close()

    def GenerateTreeImage(self, fixed_horizontal_positions = False):
        &#34;&#34;&#34;
        Generate files necessary for a tree image.
        Two files are necessary: a data file and a Gnuplot script file (which
        references the data file).
        &#34;&#34;&#34;
        index_string = self.GetImageCounterString()
        if fixed_horizontal_positions:
            name_prefix = &#39;tree_alt&#39;
            horizontal_positions = self.GetTreeFixedHorizontalPositions()
        else:
            name_prefix = &#39;tree&#39;
            horizontal_positions = self.GetTreeHorizontalPositions()
        candidate_lines = []
        pregnant_lines = []
        branched_lines = []
        infeasible_lines = []
        fathomed_lines = []
        integer_lines = []
        additional_script_lines = []
        node_list = self.get_node_list()
        print_edges = (len(node_list) &lt;= self._edge_limit)
        for node in node_list:
            node_lp_bound = self.get_node_attr(node, &#39;lp_bound&#39;)
            if self.get_node_attr(node, &#39;status&#39;) == &#39;candidate&#39;:
                # TODO(bhunsaker): add optional fathoming check
                candidate_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;pregnant&#39;:
                # TODO(bhunsaker): add optional fathoming check
                pregnant_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;branched&#39;:
                branched_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;infeasible&#39;:
                infeasible_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;fathomed&#39;:
                fathomed_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            elif self.get_node_attr(node, &#39;status&#39;) == &#39;integer&#39;:
                integer_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                        horizontal_positions[node], node_lp_bound))
            if print_edges and node != self.root.name:
                if True:
                    _parent_id = self.get_node_attr(node, &#39;parent&#39;)
                    additional_script_lines.append(
                     &#39;set arrow from %0.6f, %0.6f to %0.6f, %0.6f nohead lt -1 &#39;
                     &#39;lw 0.2\n&#39; % (horizontal_positions[_parent_id],
                     self.get_node_attr(_parent_id, &#39;lp_bound&#39;),
                     horizontal_positions[node],
                     self.get_node_attr(node, &#39;lp_bound&#39;)))
        plot_parts = []
        # Plot root node.
        plot_parts.append(&#39;&#34;&lt; echo %0.6f %0.6f&#34; w p lt 2 pt 7&#39; %
                          (horizontal_positions[self.root.name],
                           self.root.get_attr(&#39;lp_bound&#39;)))
        # If desired, sample from the set of nodes rather than plotting all.
        if self._sample_tree:
            sample_size = self._sample_tree
            if len(branched_lines) &gt; sample_size:
                branched_lines = random.sample(branched_lines, sample_size)
            if len(fathomed_lines) &gt; sample_size:
                fathomed_lines = random.sample(fathomed_lines, sample_size)
            if len(infeasible_lines) &gt; sample_size:
                infeasible_lines = random.sample(infeasible_lines, sample_size)
            if len(pregnant_lines) &gt; sample_size:
                pregnant_lines = random.sample(pregnant_lines, sample_size)
            if len(candidate_lines) &gt; sample_size:
                candidate_lines = random.sample(candidate_lines, sample_size)
            if len(integer_lines) &gt; sample_size:
                integer_lines = random.sample(integer_lines, sample_size)
        # Output all data files.  Note that the order below matters.
        if len(branched_lines):
            self.WriteDataFileFromList(&#39;%s_branched%s.dat&#39; % (name_prefix,
                                                              index_string),
                                       branched_lines)
            plot_parts.append(&#39;\&#39;%s_branched%s.dat\&#39; w p lt rgb &#34;yellow&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(fathomed_lines):
            self.WriteDataFileFromList(&#39;%s_fathomed%s.dat&#39; % (name_prefix,
                                                              index_string),
                                       fathomed_lines)
            plot_parts.append(&#39;\&#39;%s_fathomed%s.dat\&#39; w p lt rgb &#34;light-red&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(infeasible_lines):
            self.WriteDataFileFromList(&#39;%s_infeasible%s.dat&#39; % (name_prefix,
                                                                index_string),
                                       infeasible_lines)
            plot_parts.append(&#39;\&#39;%s_infeasible%s.dat\&#39; w p lt rgb &#34;dark-red&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(pregnant_lines):
            self.WriteDataFileFromList(&#39;%s_pregnant%s.dat&#39; % (name_prefix,
                                                              index_string),
                                       pregnant_lines)
            plot_parts.append(&#39;\&#39;%s_pregnant%s.dat\&#39; w p lt rgb &#34;green&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if len(candidate_lines):
            for line in candidate_lines:
                plot_parts.append(&#39;&#34;&lt; echo %s&#34; w p lt rgb &#34;green&#34; pt 7&#39;
                                  %line.rstrip(&#39;\r\n&#39;))
        if len(integer_lines):
            self.WriteDataFileFromList(&#39;%s_integer%s.dat&#39; % (name_prefix,
                                                             index_string),
                                       integer_lines)
            plot_parts.append(&#39;\&#39;%s_integer%s.dat\&#39; w p lt rgb &#34;cyan&#34; pt 7&#39; %
                              (name_prefix, index_string))
        if self._incumbent_value is not None:
            plot_parts.append(&#39;%0.6f lt 1 lw 0.5&#39; % self._incumbent_value)
        additional_script_lines.append(&#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts))
        additional_script_lines.append(&#39;unset arrow\n&#39;)
        image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
            self._min_objective_value, self._max_objective_value)
        data = &#39;&#39;
        data += &#39;set terminal png notransparent size 480,360\n&#39;
        data += &#39;set nokey\n&#39;
        data += &#39;set autoscale\n&#39;
        data += &#39;set tics scale 0.001\n&#39;
        data += &#39;set pointsize 0.5\n&#39;
        data += &#39;set xrange [-0.1:1.1]\n&#39;
        data += &#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_max_obj,
                                                          image_min_obj)
        data += &#39;set format x &#34;&#34;\n&#39;
        data += &#39;set ylabel &#34;obj. value&#34;\n&#39;
        if self._filename is None:
            data += &#39;set title &#34;B&amp;B tree&#34;\n\n&#39;
        else:
            data += &#39;set title &#34;B&amp;B tree (%s %.2fs %s)&#34;\n\n&#39; % (
                self._filename, self._time, self._label)
        for line in additional_script_lines:
            data += line

        return data

    def ProcessLine(self, line):
        &#34;&#34;&#34;
        Process a line of the input file, generating images if appropriate.
        Parses the line, updates internal data structures, and creates images
        if appropriate.
        Args:
          line: String input line to process.
        &#34;&#34;&#34;
        line = line.strip()
        # Comments start with a &#39;#&#39;
        if line[0] == &#39;#&#39;:
            return
        tokens = line.split()
        if len(tokens) &lt; 3:
            print(&#39;Incomplete or invalid line: %s&#39; %&#39; &#39;.join(tokens))
            sys.exit(1)
        # Tokens shared by all line types
        self._time = float(tokens[0])
        line_type = tokens[1]
        remaining_tokens = tokens[2:]
        # Process the line based on the type
        if line_type == &#39;heuristic&#39;:
            self._optimal_soln_time = self._time
            self.ProcessHeuristicLine(remaining_tokens)
        else:
            # Other node types share common tokens
            node_id = int(tokens[2])
            parent_id = int(tokens[3])
            branch_direction = tokens[4]
            remaining_tokens = tokens[5:]
            # TODO(aykut):parent id of root node is 0 when we read from file.
            if id==self.root:
                parent_id = None
            # Check that the parent node id is valid
            # elif parent_id not in self.get_node_list() and self.root is not None:
            #     print &#39;Parent id does not exist: %s&#39; % line
            #     sys.exit(1)
            if line_type == &#39;integer&#39;:
                self._optimal_soln_time = self._time
                self.ProcessIntegerLine(node_id, parent_id,
                                        branch_direction, remaining_tokens)
            elif line_type == &#39;fathomed&#39;:
                self.ProcessFathomedLine(node_id, parent_id,
                                         branch_direction, remaining_tokens)
            elif line_type == &#39;candidate&#39;:
                self.ProcessCandidateLine(node_id, parent_id,
                                          branch_direction, remaining_tokens)
            elif line_type == &#39;pregnant&#39;:
                self.ProcessPregnantLine(node_id, parent_id,
                                         branch_direction, remaining_tokens)
            elif line_type == &#39;branched&#39;:
                self.ProcessBranchedLine(node_id, parent_id,
                                         branch_direction, remaining_tokens)
            elif line_type == &#39;infeasible&#39;:
                self.ProcessInfeasibleLine(node_id, parent_id,
                                           branch_direction, remaining_tokens)
            else:
                print(&#39;Unexpected line type &#34;%s&#34;: %s&#39; % (line_type,
                                                         &#39; &#39;.join(tokens)))
                sys.exit(1)

    def ProcessHeuristicLine(self, remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;heuristic&#39;.
        Args:
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) &lt; 1 or len(remaining_tokens) &gt; 2:
            print(&#39;Invalid line: %s heuristic %s&#39; % (
                    self._time, &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; heuristic &lt;obj value&gt;&#39;+\
                &#39; [&lt;associated node id&gt;]&#39;)
            sys.exit(1)
        objective_value = float(remaining_tokens[0])
        if len(remaining_tokens) == 2:
            associated_node = remaining_tokens[1]
        else:
            associated_node = None
        # Check that this is actually an improvement
        if self._incumbent_value is not None and self._optimization_sense is None:
            if objective_value &gt; self._incumbent_value:
                print(&#34;Objective sense unset, guessing maximization&#34;)
                self._optimization_sense = &#39;max&#39;
            else:
                print(&#34;Objective sense unset, guessing minimization&#34;)
                self._optimization_sense = &#39;min&#39;
        if not self.IsBetterThanIncumbent(objective_value):
            return
        self._previous_incumbent_value = self._incumbent_value
        self._incumbent_value = objective_value
        self.UpdateObjectiveValueLimits(objective_value)
        self._incumbent_parent = associated_node
        # Set variable to generate images
        self._new_integer_solution = True

    def ProcessIntegerLine(self, node_id, parent_id, branch_direction,
                           remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;integer&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
          is the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) != 1:
            print(&#39;Invalid line: %s integer %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; integer &lt;node id&gt; &lt;parent id&gt;&#39;+\
                &#39;&lt;branch direction&gt; &lt;obj value&gt;&#39;)
            sys.exit(1)
        objective_value = float(remaining_tokens[0])
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;integer&#39;,
                             objective_value, None, None)
        self._previous_incumbent_value = self._incumbent_value
        self._incumbent_value = objective_value
        self._incumbent_parent = parent_id
        self._new_integer_solution = True

    def ProcessFathomedLine(self, node_id, parent_id, branch_direction,
                            remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;fathomed&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
            the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Print a warning if there is no current incumbent.
        if self._incumbent_value is None:
            print(&#39;WARNING: Encountered &#34;fathom&#34; line before first incumbent.&#39;)
            print(&#39;  This may indicate an error in the input file.&#39;)
        # Parse remaining tokens
        if len(remaining_tokens) &gt; 1:
            print(&#39;Invalid line: %s fathomed %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; fathomed &lt;node id&gt; &lt;parent id&gt;&#39;+\
                &#39;&lt;branch direction&gt; [&lt;lp bound&gt;]&#39;)
            sys.exit(1)
        if len(remaining_tokens) == 1:
            lp_bound = float(remaining_tokens[0])
        else:
            if (node_id in self.get_node_list() and
                self.get_node_attr(node_id, &#39;lp_bound&#39;) is not None):
                lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
            else:
                lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
            if self._optimization_sense == &#39;min&#39;:
                if (self._incumbent_value is not None and
                    lp_bound &lt; self._incumbent_value):
                    lp_bound = self._incumbent_value
            elif self._optimization_sense == &#39;max&#39;:
                if (self._incumbent_value is not None and
                    lp_bound &gt; self._incumbent_value):
                    lp_bound = self._incumbent_value
        parent_node = self.get_node(parent_id)
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;fathomed&#39;,
                             lp_bound,
                             self.get_node_attr(parent_id,
                                                &#39;integer_infeasibility_count&#39;),
                             self.get_node_attr(parent_id,
                                                &#39;integer_infeasibility_sum&#39;))

    def ProcessPregnantLine(self, node_id, parent_id, branch_direction,
                            remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;pregnant&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
            the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) != 3:
            print(&#39;Invalid line: %s pregnant %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; pregnant &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt; &lt;lp bound&gt; &#39;)
            print(&#39;&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
            print(&#39;infeasibilities&gt;&#39;)
            sys.exit(1)
        lp_bound = float(remaining_tokens[0])
        integer_infeasibility_sum = float(remaining_tokens[1])
        integer_infeasibility_count = int(remaining_tokens[2])

        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;pregnant&#39;,
                             lp_bound, integer_infeasibility_count,
                             integer_infeasibility_sum)

    def ProcessBranchedLine(self, node_id, parent_id, branch_direction,
                            remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;branched&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
          is the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) not in [3, 5]:
            print(&#39;Invalid line: %s branched %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; branched &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt; &lt;lp bound&gt; &#39;)
            print(&#39;&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
            print(&#39;infeasibilities&gt;&#39;)
            sys.exit(1)
        lp_bound = float(remaining_tokens[0])
        integer_infeasibility_sum = float(remaining_tokens[1])
        integer_infeasibility_count = int(remaining_tokens[2])
        condition_begin = None
        condition_end = None
        if len(remaining_tokens) == 5:
            # In this case, we must also be printing conditions numbers
            condition_begin = int(remaining_tokens[3])
            condition_end = int(remaining_tokens[4])
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;branched&#39;,
                             lp_bound, integer_infeasibility_count,
                             integer_infeasibility_sum, condition_begin,
                             condition_end)

    def ProcessInfeasibleLine(self, node_id, parent_id, branch_direction,
                              remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;infeasible&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
            the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) not in [0, 2]:
            print(&#39;Invalid line: %s infeasible %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; infeasible &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt;&#39;)
            sys.exit(1)
        # Use parent values if the node does not have its own
        lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
        ii_count = self.get_node_attr(parent_id, &#39;integer_infeasibility_count&#39;)
        ii_sum = self.get_node_attr(parent_id, &#39;integer_infeasibility_sum&#39;)
        if node_id in self.get_node_list():
            if self.get_node_attr(node_id, &#39;lp_bound&#39;) is not None:
                lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
            if (self.get_node_attr(node_id, &#39;integer_infeasibility_count&#39;)
                is not None):
                ii_count = self.get_node_attr(node_id,
                                              &#39;integer_infeasibility_count&#39;)
            if (self.get_node_attr(node_id, &#39;integer_infeasibility_sum&#39;)
                is not None):
                ii_sum = self.get_node_attr(node_id,&#39;integer_infeasibility_sum&#39;)
        if len(remaining_tokens) == 2:
            # In this case, we must also be printing conditions numbers
            condition_begin = int(remaining_tokens[0])
            condition_end = int(remaining_tokens[1])
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;infeasible&#39;,
                             lp_bound, ii_count, ii_sum)

    def ProcessCandidateLine(self, node_id, parent_id, branch_direction,
                             remaining_tokens):
        &#34;&#34;&#34;
        Core processing for a line of type &#39;candidate&#39;.
        Args:
          node_id: String node id.
          parent_id: String node id of parent.
          branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
          is the left or right child of its parent.
          remaining_tokens: List of string tokens. These are those that remain
            after any common tokens are processed.
        &#34;&#34;&#34;
        # Parse remaining tokens
        if len(remaining_tokens) == 2 or len(remaining_tokens) &gt; 3:
            print(&#39;Invalid line: %s branched %s %s %s %s&#39; % (
                    self._time, node_id, parent_id, branch_direction,
                    &#39; &#39;.join(remaining_tokens)))
            print(&#39;Should match: &lt;time&gt; candidate &lt;node id&gt; &lt;parent id&gt; &#39;)
            print(&#39;&lt;branch direction&gt; [&lt;lp bound&gt;] &#39;)
            print(&#39;[&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
            print(&#39;infeasibilities&gt;]&#39;)
            sys.exit(1)
        # if parent_id not in self.get_node_list():
        #     print &#39;Error: node %s not in set&#39; % parent_id
        #     sys.exit(1)
        # TODO(bhunsaker): Check that we handle the cases of updating a
        #candidate.
        if len(remaining_tokens) &gt; 0:
            lp_bound = float(remaining_tokens[0])
        else:
            lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
        if len(remaining_tokens) == 3:
            integer_infeasibility_sum = float(remaining_tokens[1])
            integer_infeasibility_count = int(remaining_tokens[2])
        else:
            integer_infeasibility_sum = self.get_node_attr(parent_id,
                                                  &#39;integer_infeasibility_sum&#39;)
            integer_infeasibility_count = self.get_node_attr(parent_id,
                                                &#39;integer_infeasibility_count&#39;)
        self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;candidate&#39;,
                             lp_bound, integer_infeasibility_count,
                             integer_infeasibility_sum)

    def RunGnuplotOnAllFiles(self):
        &#34;&#34;&#34;Runs Gnuplot on all files in self._gnuplot_files.&#34;&#34;&#34;
        for file in self._gnuplot_files:
            subprocess.call([&#39;gnuplot&#39;, file])

    def CreateAnimatedImages(self):
        &#34;&#34;&#34;Create animated images based on the static images.&#34;&#34;&#34;
        histogram_re = re.compile(&#39;histogram&#39;)
        histogram_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                            for file in self._gnuplot_files
                            if histogram_re.match(file)]
        if len(histogram_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(histogram_images)
            args.append(&#39;animated_histogram.gif&#39;)
            subprocess.call(args)
        scatterplot_re = re.compile(&#39;scatterplot&#39;)
        scatterplot_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                              for file in self._gnuplot_files
                              if scatterplot_re.match(file)]
        if len(scatterplot_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(scatterplot_images)
            args.append(&#39;animated_scatterplot.gif&#39;)
            subprocess.call(args)
        tree_re = re.compile(&#39;tree\.&#39;)
        tree_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                       for file in self._gnuplot_files
                       if tree_re.match(file)]
        if len(tree_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(tree_images)
            args.append(&#39;animated_tree.gif&#39;)
            subprocess.call(args)
        tree_alt_re = re.compile(&#39;tree_alt&#39;)
        tree_alt_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                           for file in self._gnuplot_files
                           if tree_alt_re.match(file)]
        if len(tree_alt_images):
            args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
            args.extend(tree_alt_images)
            args.append(&#39;animated_tree_alt.gif&#39;)
            subprocess.call(args)

    def GeneratePredictionImages(self):
        gap_measures = self._objective_gap_forecaster.GetAllMeasures()
        ssg_measures = self._sum_subtree_gaps_forecaster.GetAllMeasures()
        # Check that there are values to process.
        if len(gap_measures) == 0 or len(ssg_measures) == 0:
            print(&#39;WARNING: Not printing prediction images because at least&#39;+\
                &#39; one measure set is empty.&#39;)
            print(&#39;  Gap measures: %d&#39; % len(gap_measures))
            print(&#39;  SSG measures: %d&#39; % len(ssg_measures))
            return
        # Gap measures
        gap_data_filename = &#39;gap_measures.dat&#39;
        data_file = open(gap_data_filename, &#39;w&#39;)
        for measure in gap_measures:
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (measure.time, measure.value))
        data_file.close()
        # SSG measures
        ssg_data_filename = &#39;ssg_measures.dat&#39;
        data_file = open(ssg_data_filename, &#39;w&#39;)
        # We need to scale the SSG measures so that it will make sense to
        # look at them on the same plot with gap measures.
        scale_factor=old_div(float(gap_measures[0].value),float(ssg_measures[0].value))
        for measure in ssg_measures:
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (measure.time,
                                               measure.value * scale_factor))
        data_file.close()
        # Set terminal for the output files.
        measures_script = &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the plot.
        if self.filename is None:
            measures_script += &#39;set title &#34;Progress Measures&#34;\n&#39;
        else:
            measures_script += (&#39;set title &#34;Progress Measures: %s, %s&#34;\n&#39; % (
                    self._filename, self._label))
        measures_script += &#39;set xlabel \&#34;time (s)\&#34;\n&#39;
        measures_script += &#39;set ylabel \&#34;measure\&#34;\n&#39;
        measures_script += &#39;set autoscale\n&#39;
        # Plot the data points.
        measures_script += (
            &#39;plot \&#39;%s\&#39; with linespoints linetype 3 title \&#34;(SSG)\&#34;, &#39;
            &#39;\&#39;%s\&#39; with linespoints linetype 4 pointtype 19 &#39;
            &#39;title \&#34;(MIP gap)\&#34;\n&#39; %
            (ssg_data_filename, gap_data_filename))
        measures_script += &#39;show output\n&#39;

        return measures_script

    def GenerateForecastImages(self):
        # Forecasts
        # Gap forecasts
        gap_forecasts = self._objective_gap_forecaster.GetAllForecasts()
        gap_data_filename = &#39;gap_forecasts.dat&#39;
        if gap_forecasts:
            data_file = open(gap_data_filename, &#39;w&#39;)
            for forecast in gap_forecasts:
                data_file.write(&#39;%0.6f %0.6f\n&#39; % (forecast.time,
                                                   forecast.forecast))
            data_file.close()
        # SSG forecasts
        ssg_forecasts = self._sum_subtree_gaps_forecaster.GetAllForecasts()
        ssg_data_filename = &#39;ssg_forecasts.dat&#39;
        if ssg_forecasts:
            data_file = open(ssg_data_filename, &#39;w&#39;)
            for forecast in ssg_forecasts:
                data_file.write(&#39;%0.6f %0.6f\n&#39; % (forecast.time,
                                                   forecast.forecast))
            data_file.close()
        if not gap_forecasts and not ssg_forecasts:
            print(&#39;No forecasts made, so not creating forecast image.&#39;)
            return
        # Set terminal for the output files.
        forecast_script = &#39;set terminal png notransparent size 480,360\n\n&#39;
        # Make settings for the plot.
        if self._filename is None:
            forecast_script += &#39;set title &#34;Forecasts&#34;\n&#39;
        else:
            forecast_script += (&#39;set title &#34;Forecasts: %s, %s&#34;\n&#39; % (
                    self._filename, self._label))
        forecast_script += &#39;set xlabel \&#34;time (s)\&#34;\n&#39;
        forecast_script += &#39;set ylabel \&#34;prediction of total time\&#34;\n&#39;
        forecast_script += &#39;set autoscale\n&#39;
        # Plot the data points and the unit-slope line (to show elapsed time).
        forecast_script += &#39;plot &#39;
        if forecast_forecasts:
            forecast_script += (&#39;\&#39;%s\&#39; with linespoints linetype 3 &#39;
                              &#39;title \&#34;(SSG)\&#34;, &#39; % ssg_data_filename)
        if gap_forecasts:
            forecast_script += (&#39;\&#39;%s\&#39; with linespoints linetype 4 pointtype 19 &#39;
            &#39;title \&#34;(MIP gap)\&#34;, &#39; % gap_data_filename)
        forecast_script += &#39;x linetype 0 title \&#34;elapsed time\&#34;\n&#39;
        forecast_script += &#39;show output\n&#39;

        return forecast_script

    def _get_fh(self, path, mode=&#39;r&#39;):
        &#39;&#39;&#39;
        Return a file handle for given path.
        Path can be a string or a file handle.
        Attempt to uncompress/compress files ending in &#39;.gz&#39; and &#39;.bz2&#39;.
        &#39;&#39;&#39;
        if self._is_string_like(path):
            if path.endswith(&#39;.gz&#39;):
#               import gzip
#               fh = gzip.open(path,mode=mode)  # doesn&#39;t return real fh
                fh=os.popen(&#34;gzcat &#34;+path) # probably not portable
            elif path.endswith(&#39;.bz2&#39;):
#               import bz2
#               fh = bz2.BZ2File(path,mode=mode) # doesn&#39;t return real fh
                fh=os.popen(&#34;bzcat &#34;+path) # probably not portable
            else:
                fh = file(path,mode=mode)
        elif hasattr(path, &#39;write&#39;):
            # Note, mode of file handle is unchanged.
            fh = path
        else:
            raise TypeError(&#39;path must be a string or file handle.&#39;)
        return fh

    def _is_string_like(self, obj): # from John Hunter, types-free version
        try:
            obj + &#39;&#39;
        except (TypeError, ValueError):
            return False
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>coinor.gimpy.tree.BinaryTree</li>
<li>coinor.gimpy.tree.Tree</li>
<li>coinor.gimpy.graph.Graph</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="coinor.grumpy.BBTree.BBTree.AddOrUpdateNode"><code class="name flex">
<span>def <span class="ident">AddOrUpdateNode</span></span>(<span>self, id, parent_id, branch_direction, status, lp_bound, integer_infeasibility_count, integer_infeasibility_sum, condition_begin=None, condition_end=None, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method designed to update nodes (in BAK) but we use it for
updating/adding arcs. This is because of the tree data structure the
authors adopted in BAK.
We can divide these attributes such that some will belong to the edge
parent_id-&gt;id and the others belong to the id node. The following shows
whether the attribute belongs to edge or node.
branch direction -&gt; edge
status -&gt; node
lp_bound -&gt; node
integer_infeasibility_count -&gt; node
integer_infeasibility_sum -&gt; node
parent_id -&gt; node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddOrUpdateNode(self, id, parent_id, branch_direction, status, lp_bound,
                    integer_infeasibility_count, integer_infeasibility_sum,
                    condition_begin = None, condition_end = None,
                    **attrs):
    &#39;&#39;&#39;
    This method designed to update nodes (in BAK) but we use it for
    updating/adding arcs. This is because of the tree data structure the
    authors adopted in BAK.
    We can divide these attributes such that some will belong to the edge
    parent_id-&gt;id and the others belong to the id node. The following shows
    whether the attribute belongs to edge or node.
    branch direction -&gt; edge
    status -&gt; node
    lp_bound -&gt; node
    integer_infeasibility_count -&gt; node
    integer_infeasibility_sum -&gt; node
    parent_id -&gt; node
    &#39;&#39;&#39;
    if (condition_begin is not None) and (condition_end is not None):
        #Figure out the color
        attrs[&#39;init_log_cond&#39;] = math.log(condition_begin, 10)
        attrs[&#39;final_log_cond&#39;] = math.log(condition_end, 10)
    if id in self.neighbors:
        # node already exists, update attributes
        self.set_node_attr(id, &#39;status&#39;, status)
        self.set_node_attr(id, &#39;lp_bound&#39;, lp_bound)
        self.set_node_attr(id, &#39;integer_infeasibility_count&#39;,
                           integer_infeasibility_count)
        self.set_node_attr(id, &#39;integer_infeasibility_sum&#39;,
                           integer_infeasibility_sum)
        if (condition_begin is not None) and (condition_end is not None):
            self.set_node_attr(id, &#39;init_log_cond&#39;,
                               math.log(condition_begin, 10))
            self.set_node_attr(id, &#39;final_log_cond&#39;,
                               math.log(condition_end, 10))
    elif self.root is None:
        self.add_root(id, status = status, lp_bound = lp_bound,
                      integer_infeasibility_count = integer_infeasibility_count,
                      integer_infeasibility_sum = integer_infeasibility_sum,
                      subtree_root = None, **attrs)
    elif parent_id is not None:
        if branch_direction == &#39;L&#39;:
            self.add_left_child(id, parent_id, status = status,
                lp_bound = lp_bound,
                integer_infeasibility_count = integer_infeasibility_count,
                integer_infeasibility_sum = integer_infeasibility_sum,
                subtree_root = None, **attrs)
        elif branch_direction == &#39;R&#39;:
            self.add_right_child(id, parent_id, status = status,
                lp_bound = lp_bound,
                integer_infeasibility_count = integer_infeasibility_count,
                integer_infeasibility_sum = integer_infeasibility_sum,
                subtree_root = None, **attrs)
    else:
        print(&#39;this should not happen.&#39;)
        raise Exception()
    if lp_bound is not None:
        self.UpdateObjectiveValueLimits(lp_bound)
        # Set optimization sense if not yet set
        if self._optimization_sense is None:
            if lp_bound &lt; self.root.get_attr(&#39;lp_bound&#39;):
                self._optimization_sense = &#39;max&#39;
            elif lp_bound &gt; self.root.get_attr(&#39;lp_bound&#39;):
                self._optimization_sense = &#39;min&#39;
        if self._optimization_sense == &#39;min&#39; and lp_bound &lt; self.root.get_attr(&#39;lp_bound&#39;):
            print(&#34;Switching guess about objective sense to maximization based on bound change&#34;)
            self._optimization_sense = &#39;max&#39;
        if self._optimization_sense == &#39;max&#39; and lp_bound &gt; self.root.get_attr(&#39;lp_bound&#39;):
            print(&#34;Switching guess about objective sense to minimization based on bound change&#34;)
            self._optimization_sense = &#39;max&#39;
    if integer_infeasibility_sum is not None:
        if (self._max_integer_infeasibility_sum is None or
            integer_infeasibility_sum &gt;
            self._max_integer_infeasibility_sum):
            self._max_integer_infeasibility_sum = integer_infeasibility_sum</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.AddProgressMeasures"><code class="name flex">
<span>def <span class="ident">AddProgressMeasures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddProgressMeasures(self):
    # No progress measures if there is no incumbent yet
    if self._incumbent_value is None:
        return
    # Store sum-of-subtree-gaps
    # We need to traverse all nodes unfortunately
    # TODO(bhunsaker): check whether we can just traverse active nodes
    active_node_count = 0
    subtree_bounds = {}
    new_integer_ssg = 0  # Only needed if this is a new integer solution
    for node_id in self.get_node_list():
        status = self.get_node_attr(node_id, &#39;status&#39;)
        if status == &#39;candidate&#39; or status == &#39;pregnant&#39;:
            lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
            subtree_root = self.get_node_attr(node_id, &#39;subtree_root&#39;)
            # Optional check for fathomed nodes.
            if (self._fathom and
                not self.IsBetterThanIncumbent(lp_bound)):
                continue
            active_node_count += 1
            if (subtree_root not in subtree_bounds or
                self.IsBetterThan(lp_bound, subtree_bounds[subtree_root])):
                subtree_bounds[subtree_root] = lp_bound
            if self._new_integer_solution:
                self.set_node_attr(node_id, &#39;subtree_root&#39;, id)
                new_integer_ssg += abs(self._incumbent_value - lp_bound)
    # If we have a new integer solution, we need to compute what
    # the measure would be with the previous integer solution for
    # scaling purposes.
    if (self._new_integer_solution and
        self._previous_incumbent_value is not None):
        reference_value = self._previous_incumbent_value
    else:
        reference_value = self._incumbent_value
    sum_subtree_gaps = 0
    for lp_bound in list(subtree_bounds.values()):
        sum_subtree_gaps += abs(reference_value - lp_bound)
    # Start a new sequence if a new integer solution was just found
    if self._new_integer_solution:
        if new_integer_ssg &gt;= 1e-6:
            scale_factor = (old_div(float(sum_subtree_gaps),
                            float(new_integer_ssg)))
        else:
            scale_factor = 1.0
        self._sum_subtree_gaps_forecaster.StartNewSequence(scale_factor)
        # sum_subtree_gaps was based on the previous integer solution;
        # update it now
        sum_subtree_gaps = new_integer_ssg
    self._sum_subtree_gaps_forecaster.AddMeasure(self._time,
                                                 sum_subtree_gaps,
                                                 active_node_count,
                                                 len(self.get_node_list()))
    # Add objective gap measure.  Note that this relies on the
    # active_node_count computed above.
    if self._new_integer_solution:
        self._objective_gap_forecaster.StartNewSequence(1.0)
    if self._optimization_sense == &#39;min&#39;:
        obj_gap = self._incumbent_value - self._min_objective_value
    else:
        obj_gap = self._max_objective_value - self._incumbent_value
    self._objective_gap_forecaster.AddMeasure(self._time, obj_gap,
                                              active_node_count,
                                              len(self.get_node_list()))</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.AdjustHistogramEndBins"><code class="name flex">
<span>def <span class="ident">AdjustHistogramEndBins</span></span>(<span>self, objective_list, num_bins, bin_width, bin_counts, bin_centers, bin_widths)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjusts the two end bins if necessary to make them narrower.
The two end bins may need to be narrower than the other bins so that
they do not go past the current incumbent value on one end and the
current lp bound on the other.
So that the histogram is still correct
in areas, the height of these bins needs to be adjusted so that the
area does not change.</p>
<p>Note that there is likely to be some bias toward taller bins on
the ends since they always have a point at one end of their width.
It
may be more accurate visually to ignore or discount that one point when
determining the bin height, but that is not currently done.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>objective_list</code></strong></dt>
<dd>List of float objective values.</dd>
<dt><strong><code>num_bins</code></strong></dt>
<dd>Integer number of bins.</dd>
<dt><strong><code>bin_width</code></strong></dt>
<dd>Float standard width of bins in terms of objective values.</dd>
<dt><strong><code>bin_counts</code></strong></dt>
<dd>List of integer counts for each bin.</dd>
<dt><strong><code>bin_centers</code></strong></dt>
<dd>List of float coordinates for the center of each bin.</dd>
<dt><strong><code>bin_widths</code></strong></dt>
<dd>List of float widths for bins, allowing for individualized
widths.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AdjustHistogramEndBins(self, objective_list, num_bins, bin_width,
                           bin_counts, bin_centers, bin_widths):
    &#34;&#34;&#34;
    Adjusts the two end bins if necessary to make them narrower.
    The two end bins may need to be narrower than the other bins so that
    they do not go past the current incumbent value on one end and the
    current lp bound on the other.  So that the histogram is still correct
    in areas, the height of these bins needs to be adjusted so that the
    area does not change.

    Note that there is likely to be some bias toward taller bins on
    the ends since they always have a point at one end of their width.  It
    may be more accurate visually to ignore or discount that one point when
    determining the bin height, but that is not currently done.

    Args:
      objective_list: List of float objective values.
      num_bins: Integer number of bins.
      bin_width: Float standard width of bins in terms of objective values.
      bin_counts: List of integer counts for each bin.
      bin_centers: List of float coordinates for the center of each bin.
      bin_widths: List of float widths for bins, allowing for individualized
        widths.
    &#34;&#34;&#34;
    if self._optimization_sense == &#39;min&#39;:
        lp_bound = min(objective_list)
        lower_bound = lp_bound
        if self._incumbent_value is not None:
            upper_bound = self._incumbent_value
        else:
            upper_bound = self._histogram_upper_bound
    else:
        lp_bound = max(objective_list)
        upper_bound = lp_bound
        if self._incumbent_value is not None:
            lower_bound = self._incumbent_value
        else:
            lower_bound = self._histogram_lower_bound
    # The end bins may have unusual centers and widths
    highest_nonempty_bin = int((upper_bound -
                                self._histogram_lower_bound) // bin_width)
    if (highest_nonempty_bin &lt; num_bins and
        bin_counts[highest_nonempty_bin] &gt; 0):
        highest_x_coord = 0.5 + (old_div((upper_bound -
                                  self._histogram_lower_bound), bin_width))
        highest_nonempty_bin_width, unused_int = math.modf(0.5 +
                                                           highest_x_coord)
        if highest_nonempty_bin_width == 0.0:
            highest_nonempty_bin_width = 1.0
        bin_widths[highest_nonempty_bin] = highest_nonempty_bin_width
        bin_centers[highest_nonempty_bin] = highest_x_coord - (
            old_div(highest_nonempty_bin_width, 2))
        # Scale the height appropriately
        bin_counts[highest_nonempty_bin] /= bin_widths[highest_nonempty_bin]
    lowest_nonempty_bin = int((lower_bound -
                               self._histogram_lower_bound) // bin_width)
    if bin_counts[lowest_nonempty_bin] &gt; 0:
        lowest_x_coord = 0.5 + (old_div((lower_bound -
                                 self._histogram_lower_bound), bin_width))
        lowest_nonempty_bin_excess, unused_int = math.modf(0.5 +
                                                           lowest_x_coord)
        bin_widths[lowest_nonempty_bin] = 1.0 - lowest_nonempty_bin_excess
        bin_centers[lowest_nonempty_bin] = (
            lowest_x_coord + old_div(bin_widths[lowest_nonempty_bin], 2))
        # Scale the height appropriately
        bin_counts[lowest_nonempty_bin] /= bin_widths[lowest_nonempty_bin]</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.CreateAnimatedImages"><code class="name flex">
<span>def <span class="ident">CreateAnimatedImages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create animated images based on the static images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateAnimatedImages(self):
    &#34;&#34;&#34;Create animated images based on the static images.&#34;&#34;&#34;
    histogram_re = re.compile(&#39;histogram&#39;)
    histogram_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                        for file in self._gnuplot_files
                        if histogram_re.match(file)]
    if len(histogram_images):
        args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
        args.extend(histogram_images)
        args.append(&#39;animated_histogram.gif&#39;)
        subprocess.call(args)
    scatterplot_re = re.compile(&#39;scatterplot&#39;)
    scatterplot_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                          for file in self._gnuplot_files
                          if scatterplot_re.match(file)]
    if len(scatterplot_images):
        args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
        args.extend(scatterplot_images)
        args.append(&#39;animated_scatterplot.gif&#39;)
        subprocess.call(args)
    tree_re = re.compile(&#39;tree\.&#39;)
    tree_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                   for file in self._gnuplot_files
                   if tree_re.match(file)]
    if len(tree_images):
        args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
        args.extend(tree_images)
        args.append(&#39;animated_tree.gif&#39;)
        subprocess.call(args)
    tree_alt_re = re.compile(&#39;tree_alt&#39;)
    tree_alt_images = [re.sub(&#39;gnuplot&#39;, &#39;png&#39;, file)
                       for file in self._gnuplot_files
                       if tree_alt_re.match(file)]
    if len(tree_alt_images):
        args = [&#39;convert&#39;, &#39;-delay&#39;, &#39;15&#39;, &#39;-loop&#39;, &#39;1&#39;]
        args.extend(tree_alt_images)
        args.append(&#39;animated_tree_alt.gif&#39;)
        subprocess.call(args)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GenerateAllIncumbentPaths"><code class="name flex">
<span>def <span class="ident">GenerateAllIncumbentPaths</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate file for a path image with all incumbent paths.
Data files were previously generated for each incumbent.
This re-uses
those files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateAllIncumbentPaths(self):
    &#34;&#34;&#34;
    Generate file for a path image with all incumbent paths.
    Data files were previously generated for each incumbent.  This re-uses
    those files.
    &#34;&#34;&#34;
    all_path_script = self.WriteAllIncumbentPathsScript()</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GenerateForecastImages"><code class="name flex">
<span>def <span class="ident">GenerateForecastImages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateForecastImages(self):
    # Forecasts
    # Gap forecasts
    gap_forecasts = self._objective_gap_forecaster.GetAllForecasts()
    gap_data_filename = &#39;gap_forecasts.dat&#39;
    if gap_forecasts:
        data_file = open(gap_data_filename, &#39;w&#39;)
        for forecast in gap_forecasts:
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (forecast.time,
                                               forecast.forecast))
        data_file.close()
    # SSG forecasts
    ssg_forecasts = self._sum_subtree_gaps_forecaster.GetAllForecasts()
    ssg_data_filename = &#39;ssg_forecasts.dat&#39;
    if ssg_forecasts:
        data_file = open(ssg_data_filename, &#39;w&#39;)
        for forecast in ssg_forecasts:
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (forecast.time,
                                               forecast.forecast))
        data_file.close()
    if not gap_forecasts and not ssg_forecasts:
        print(&#39;No forecasts made, so not creating forecast image.&#39;)
        return
    # Set terminal for the output files.
    forecast_script = &#39;set terminal png notransparent size 480,360\n\n&#39;
    # Make settings for the plot.
    if self._filename is None:
        forecast_script += &#39;set title &#34;Forecasts&#34;\n&#39;
    else:
        forecast_script += (&#39;set title &#34;Forecasts: %s, %s&#34;\n&#39; % (
                self._filename, self._label))
    forecast_script += &#39;set xlabel \&#34;time (s)\&#34;\n&#39;
    forecast_script += &#39;set ylabel \&#34;prediction of total time\&#34;\n&#39;
    forecast_script += &#39;set autoscale\n&#39;
    # Plot the data points and the unit-slope line (to show elapsed time).
    forecast_script += &#39;plot &#39;
    if forecast_forecasts:
        forecast_script += (&#39;\&#39;%s\&#39; with linespoints linetype 3 &#39;
                          &#39;title \&#34;(SSG)\&#34;, &#39; % ssg_data_filename)
    if gap_forecasts:
        forecast_script += (&#39;\&#39;%s\&#39; with linespoints linetype 4 pointtype 19 &#39;
        &#39;title \&#34;(MIP gap)\&#34;, &#39; % gap_data_filename)
    forecast_script += &#39;x linetype 0 title \&#34;elapsed time\&#34;\n&#39;
    forecast_script += &#39;show output\n&#39;

    return forecast_script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GenerateHistogram"><code class="name flex">
<span>def <span class="ident">GenerateHistogram</span></span>(<span>self, output_file=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate files necessary for a histogram image.
Two files are necessary: a data file and a Gnuplot script file (which
references the data file).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>time</code></strong></dt>
<dd>Float number of seconds since the start of optimization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateHistogram(self, output_file = False):
    &#34;&#34;&#34;
    Generate files necessary for a histogram image.
    Two files are necessary: a data file and a Gnuplot script file (which
    references the data file).
    Args:
      time: Float number of seconds since the start of optimization.
    &#34;&#34;&#34;
    num_bins = 20
    # Compute the bin width and counts.
    objective_list = []
    for n in self.get_node_list():
        if (self.get_node_attr(n,&#39;status&#39;) == &#39;candidate&#39; or
            self.get_node_attr(n,&#39;status&#39;) == &#39;pregnant&#39;):
            lp_bound = self.get_node_attr(n,&#39;lp_bound&#39;)
            if not self.IsBetterThanIncumbent(lp_bound):
                continue
            objective_list.append(lp_bound)
    # TODO(aykut) added the following check, we need it since we generate
    # histograms real time
    # we can not generate histogram if we do not have upperl and lower
    #bounds
    if len(objective_list)==0 or self._incumbent_value is None:
        return None
    # The first time we create a histogram, set bounds for objective
    # values.
    # TODO(bhunsaker): Consider bounds; talk to Osman.
    if self._histogram_lower_bound is None:
        if self._optimization_sense == &#39;min&#39;:
            self._histogram_lower_bound = min(objective_list)
            if self._incumbent_value is not None:
                self._histogram_upper_bound = self._incumbent_value
            else:
                self._histogram_upper_bound = max(objective_list)
        else:
            self._histogram_upper_bound = max(objective_list)
            if self._incumbent_value is not None:
                self._histogram_lower_bound = self._incumbent_value
            else:
                self._histogram_lower_bound = min(objective_list)
    bin_width = old_div((self._histogram_upper_bound -
                 self._histogram_lower_bound), float(num_bins))
    bin_counts = [0.0 for i in range(num_bins)]
    for value in objective_list:
        bin = int(math.floor(old_div((value - self._histogram_lower_bound),
                             bin_width)))
        # Special case for the largest value.
        if (value &gt;= self._histogram_upper_bound and
            value &lt; self._histogram_upper_bound + 1e-6):
            bin = num_bins - 1
        if bin &lt; 0:
            return
        assert bin &lt; num_bins, &#39;%d (%f) !&lt; %d (%f)&#39; % (
            bin, value, num_bins, self._histogram_upper_bound)
        bin_counts[bin] += 1
    max_bin_count = max(bin_counts)
    bin_centers = [i + 1.0 for i in range(len(bin_counts))]
    bin_widths = [1.0 for i in range(len(bin_counts))]
    self.AdjustHistogramEndBins(objective_list, num_bins, bin_width,
                                bin_counts, bin_centers, bin_widths)
    if self._optimization_sense == &#39;min&#39;:
        lp_bound = min(objective_list)
    else:
        lp_bound = max(objective_list)
    # Output the bin data to a file.
    index_string = self.GetImageCounterString()
    data_filename = &#39;histogram%s.dat&#39; % index_string
    data_file = open(data_filename, &#39;w&#39;)
    for index in range(len(bin_counts)):
        data_file.write(&#39;%f %f %f\n&#39; % (bin_centers[index],
                                        bin_counts[index],
                                        bin_widths[index]))
    data_file.close()
    histogram_script = self.WriteHistogramScript(num_bins, bin_width,
                       max_bin_count, lp_bound, data_filename, output_file)
    # TODO(bhunsaker): Temporary hack
    #   This allows the bounds to be reset until an incumbent is found.
    if self._incumbent_value is None:
        self._histogram_lower_bound = None
        self._histogram_upper_bound = None
    return histogram_script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GenerateIncumbentPath"><code class="name flex">
<span>def <span class="ident">GenerateIncumbentPath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate files necessary for an incumbent scatterplot path image.
Two files are necessary: a data file and a Gnuplot script file (which
references the data file).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateIncumbentPath(self):
    &#34;&#34;&#34;
    Generate files necessary for an incumbent scatterplot path image.
    Two files are necessary: a data file and a Gnuplot script file (which
    references the data file).
    &#34;&#34;&#34;
    if self._incumbent_parent is None:
        return
    if self._scatterplot_lower_bound is None:
        return
    if self._scatterplot_upper_bound is None:
        return
    index_string = self.GetImageCounterString()
    # Output data points.
    data_filename = &#39;incumbentpath%s.dat&#39; % index_string
    data_file = open(data_filename, &#39;w&#39;)
    # Write objective values and integer infeasibility sum information
    # for ancestor nodes.
    data_file.write(&#39;0 %0.6f\n&#39; % self._incumbent_value)
    parent = self._incumbent_parent
    # TODO(bhunsaker): I think the following assumes a unique value for the
    #   parent of the root.
    while parent != None:
        data_file.write(&#39;%0.6f %0.6f\n&#39;
                        % (self.get_node_attr(parent,
                           &#39;integer_infeasibility_sum&#39;),
                         self.get_node_attr(parent, &#39;lp_bound&#39;)))
        parent = self.get_node_attr(parent, &#39;parent&#39;)
    data_file.close()
    self._incumbent_path_datafiles.append(data_filename)
    # Output the Gnuplot script to a file.
    path_script = self.WriteIncumbentPathScript(data_filename)
    return path_script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GeneratePredictionImages"><code class="name flex">
<span>def <span class="ident">GeneratePredictionImages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GeneratePredictionImages(self):
    gap_measures = self._objective_gap_forecaster.GetAllMeasures()
    ssg_measures = self._sum_subtree_gaps_forecaster.GetAllMeasures()
    # Check that there are values to process.
    if len(gap_measures) == 0 or len(ssg_measures) == 0:
        print(&#39;WARNING: Not printing prediction images because at least&#39;+\
            &#39; one measure set is empty.&#39;)
        print(&#39;  Gap measures: %d&#39; % len(gap_measures))
        print(&#39;  SSG measures: %d&#39; % len(ssg_measures))
        return
    # Gap measures
    gap_data_filename = &#39;gap_measures.dat&#39;
    data_file = open(gap_data_filename, &#39;w&#39;)
    for measure in gap_measures:
        data_file.write(&#39;%0.6f %0.6f\n&#39; % (measure.time, measure.value))
    data_file.close()
    # SSG measures
    ssg_data_filename = &#39;ssg_measures.dat&#39;
    data_file = open(ssg_data_filename, &#39;w&#39;)
    # We need to scale the SSG measures so that it will make sense to
    # look at them on the same plot with gap measures.
    scale_factor=old_div(float(gap_measures[0].value),float(ssg_measures[0].value))
    for measure in ssg_measures:
        data_file.write(&#39;%0.6f %0.6f\n&#39; % (measure.time,
                                           measure.value * scale_factor))
    data_file.close()
    # Set terminal for the output files.
    measures_script = &#39;set terminal png notransparent size 480,360\n\n&#39;
    # Make settings for the plot.
    if self.filename is None:
        measures_script += &#39;set title &#34;Progress Measures&#34;\n&#39;
    else:
        measures_script += (&#39;set title &#34;Progress Measures: %s, %s&#34;\n&#39; % (
                self._filename, self._label))
    measures_script += &#39;set xlabel \&#34;time (s)\&#34;\n&#39;
    measures_script += &#39;set ylabel \&#34;measure\&#34;\n&#39;
    measures_script += &#39;set autoscale\n&#39;
    # Plot the data points.
    measures_script += (
        &#39;plot \&#39;%s\&#39; with linespoints linetype 3 title \&#34;(SSG)\&#34;, &#39;
        &#39;\&#39;%s\&#39; with linespoints linetype 4 pointtype 19 &#39;
        &#39;title \&#34;(MIP gap)\&#34;\n&#39; %
        (ssg_data_filename, gap_data_filename))
    measures_script += &#39;show output\n&#39;

    return measures_script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GenerateScatterplot"><code class="name flex">
<span>def <span class="ident">GenerateScatterplot</span></span>(<span>self, output_file=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate files necessary for a scatterplot image.
Two files are necessary: a data file and a Gnuplot script file (which
references the data file).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_file</code></strong></dt>
<dd>if not given the gnuplot image will not be written</dd>
</dl>
<p>to disk but returned (to be displayed in matplotlib window)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateScatterplot(self, output_file = False):
    &#34;&#34;&#34;
    Generate files necessary for a scatterplot image.
    Two files are necessary: a data file and a Gnuplot script file (which
    references the data file).
    Args:
        output_file: if not given the gnuplot image will not be written
    to disk but returned (to be displayed in matplotlib window)
    &#34;&#34;&#34;
    # Output data points.
    index_string = self.GetImageCounterString()
    data_filename = &#39;scatterplot%s.dat&#39; % index_string
    data_file = open(data_filename, &#39;w&#39;)
    if self._scatterplot_lower_bound is None:
        bounds = []
    # Write objective values and integer infeasibility sum information
    # for candidate and pregnant nodes.
    for node in self.get_node_list():
        status = self.get_node_attr(node, &#39;status&#39;)
        lp_bound = self.get_node_attr(node,&#39;lp_bound&#39;)
        if status == &#39;candidate&#39; or status == &#39;pregnant&#39;:
            # Optional check for fathomed nodes.
            if (self._fathom and
                not self.IsBetterThanIncumbent(lp_bound)):
                continue
            data_file.write(&#39;%0.6f %0.6f\n&#39; % (
                    self.get_node_attr(node, &#39;integer_infeasibility_sum&#39;),
                    lp_bound))
            # Set the image objective bounds the first image.
            if self._scatterplot_lower_bound is None:
                bounds.append(lp_bound)
    data_file.close()
    if self._scatterplot_lower_bound is None:
        if len(bounds) &lt;= 1:
            return None
        self._scatterplot_lower_bound = min(bounds)
        self._scatterplot_upper_bound = max(bounds)
        # The incumbent overrides a bound if present.
        if self._incumbent_value is not None:
            if self._optimization_sense == &#39;min&#39;:
                self._scatterplot_upper_bound = self._incumbent_value
            else:
                self._scatterplot_lower_bound = self._incumbent_value
    scatterplot_script = self.WriteScatterplotScript(data_filename,
                                                     output_file)
    return scatterplot_script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GenerateTreeImage"><code class="name flex">
<span>def <span class="ident">GenerateTreeImage</span></span>(<span>self, fixed_horizontal_positions=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate files necessary for a tree image.
Two files are necessary: a data file and a Gnuplot script file (which
references the data file).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GenerateTreeImage(self, fixed_horizontal_positions = False):
    &#34;&#34;&#34;
    Generate files necessary for a tree image.
    Two files are necessary: a data file and a Gnuplot script file (which
    references the data file).
    &#34;&#34;&#34;
    index_string = self.GetImageCounterString()
    if fixed_horizontal_positions:
        name_prefix = &#39;tree_alt&#39;
        horizontal_positions = self.GetTreeFixedHorizontalPositions()
    else:
        name_prefix = &#39;tree&#39;
        horizontal_positions = self.GetTreeHorizontalPositions()
    candidate_lines = []
    pregnant_lines = []
    branched_lines = []
    infeasible_lines = []
    fathomed_lines = []
    integer_lines = []
    additional_script_lines = []
    node_list = self.get_node_list()
    print_edges = (len(node_list) &lt;= self._edge_limit)
    for node in node_list:
        node_lp_bound = self.get_node_attr(node, &#39;lp_bound&#39;)
        if self.get_node_attr(node, &#39;status&#39;) == &#39;candidate&#39;:
            # TODO(bhunsaker): add optional fathoming check
            candidate_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                    horizontal_positions[node], node_lp_bound))
        elif self.get_node_attr(node, &#39;status&#39;) == &#39;pregnant&#39;:
            # TODO(bhunsaker): add optional fathoming check
            pregnant_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                    horizontal_positions[node], node_lp_bound))
        elif self.get_node_attr(node, &#39;status&#39;) == &#39;branched&#39;:
            branched_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                    horizontal_positions[node], node_lp_bound))
        elif self.get_node_attr(node, &#39;status&#39;) == &#39;infeasible&#39;:
            infeasible_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                    horizontal_positions[node], node_lp_bound))
        elif self.get_node_attr(node, &#39;status&#39;) == &#39;fathomed&#39;:
            fathomed_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                    horizontal_positions[node], node_lp_bound))
        elif self.get_node_attr(node, &#39;status&#39;) == &#39;integer&#39;:
            integer_lines.append(&#39;%0.6f %0.6f\n&#39; % (
                    horizontal_positions[node], node_lp_bound))
        if print_edges and node != self.root.name:
            if True:
                _parent_id = self.get_node_attr(node, &#39;parent&#39;)
                additional_script_lines.append(
                 &#39;set arrow from %0.6f, %0.6f to %0.6f, %0.6f nohead lt -1 &#39;
                 &#39;lw 0.2\n&#39; % (horizontal_positions[_parent_id],
                 self.get_node_attr(_parent_id, &#39;lp_bound&#39;),
                 horizontal_positions[node],
                 self.get_node_attr(node, &#39;lp_bound&#39;)))
    plot_parts = []
    # Plot root node.
    plot_parts.append(&#39;&#34;&lt; echo %0.6f %0.6f&#34; w p lt 2 pt 7&#39; %
                      (horizontal_positions[self.root.name],
                       self.root.get_attr(&#39;lp_bound&#39;)))
    # If desired, sample from the set of nodes rather than plotting all.
    if self._sample_tree:
        sample_size = self._sample_tree
        if len(branched_lines) &gt; sample_size:
            branched_lines = random.sample(branched_lines, sample_size)
        if len(fathomed_lines) &gt; sample_size:
            fathomed_lines = random.sample(fathomed_lines, sample_size)
        if len(infeasible_lines) &gt; sample_size:
            infeasible_lines = random.sample(infeasible_lines, sample_size)
        if len(pregnant_lines) &gt; sample_size:
            pregnant_lines = random.sample(pregnant_lines, sample_size)
        if len(candidate_lines) &gt; sample_size:
            candidate_lines = random.sample(candidate_lines, sample_size)
        if len(integer_lines) &gt; sample_size:
            integer_lines = random.sample(integer_lines, sample_size)
    # Output all data files.  Note that the order below matters.
    if len(branched_lines):
        self.WriteDataFileFromList(&#39;%s_branched%s.dat&#39; % (name_prefix,
                                                          index_string),
                                   branched_lines)
        plot_parts.append(&#39;\&#39;%s_branched%s.dat\&#39; w p lt rgb &#34;yellow&#34; pt 7&#39; %
                          (name_prefix, index_string))
    if len(fathomed_lines):
        self.WriteDataFileFromList(&#39;%s_fathomed%s.dat&#39; % (name_prefix,
                                                          index_string),
                                   fathomed_lines)
        plot_parts.append(&#39;\&#39;%s_fathomed%s.dat\&#39; w p lt rgb &#34;light-red&#34; pt 7&#39; %
                          (name_prefix, index_string))
    if len(infeasible_lines):
        self.WriteDataFileFromList(&#39;%s_infeasible%s.dat&#39; % (name_prefix,
                                                            index_string),
                                   infeasible_lines)
        plot_parts.append(&#39;\&#39;%s_infeasible%s.dat\&#39; w p lt rgb &#34;dark-red&#34; pt 7&#39; %
                          (name_prefix, index_string))
    if len(pregnant_lines):
        self.WriteDataFileFromList(&#39;%s_pregnant%s.dat&#39; % (name_prefix,
                                                          index_string),
                                   pregnant_lines)
        plot_parts.append(&#39;\&#39;%s_pregnant%s.dat\&#39; w p lt rgb &#34;green&#34; pt 7&#39; %
                          (name_prefix, index_string))
    if len(candidate_lines):
        for line in candidate_lines:
            plot_parts.append(&#39;&#34;&lt; echo %s&#34; w p lt rgb &#34;green&#34; pt 7&#39;
                              %line.rstrip(&#39;\r\n&#39;))
    if len(integer_lines):
        self.WriteDataFileFromList(&#39;%s_integer%s.dat&#39; % (name_prefix,
                                                         index_string),
                                   integer_lines)
        plot_parts.append(&#39;\&#39;%s_integer%s.dat\&#39; w p lt rgb &#34;cyan&#34; pt 7&#39; %
                          (name_prefix, index_string))
    if self._incumbent_value is not None:
        plot_parts.append(&#39;%0.6f lt 1 lw 0.5&#39; % self._incumbent_value)
    additional_script_lines.append(&#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts))
    additional_script_lines.append(&#39;unset arrow\n&#39;)
    image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
        self._min_objective_value, self._max_objective_value)
    data = &#39;&#39;
    data += &#39;set terminal png notransparent size 480,360\n&#39;
    data += &#39;set nokey\n&#39;
    data += &#39;set autoscale\n&#39;
    data += &#39;set tics scale 0.001\n&#39;
    data += &#39;set pointsize 0.5\n&#39;
    data += &#39;set xrange [-0.1:1.1]\n&#39;
    data += &#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_max_obj,
                                                      image_min_obj)
    data += &#39;set format x &#34;&#34;\n&#39;
    data += &#39;set ylabel &#34;obj. value&#34;\n&#39;
    if self._filename is None:
        data += &#39;set title &#34;B&amp;B tree&#34;\n\n&#39;
    else:
        data += &#39;set title &#34;B&amp;B tree (%s %.2fs %s)&#34;\n\n&#39; % (
            self._filename, self._time, self._label)
    for line in additional_script_lines:
        data += line

    return data</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GetImageCounterString"><code class="name flex">
<span>def <span class="ident">GetImageCounterString</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string with the image counter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetImageCounterString(self):
    &#34;&#34;&#34;
    Returns a string with the image counter.
    &#34;&#34;&#34;
    return &#39;%03d&#39; % self._image_counter</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GetImageObjectiveBounds"><code class="name flex">
<span>def <span class="ident">GetImageObjectiveBounds</span></span>(<span>self, min_value, max_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min and max bounds to be used for images.
Images should use bounds that are slightly wider than observed
objective values.
Also, the special case of a single value must be
handled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min_value</code></strong></dt>
<dd>Float minimum objective value.</dd>
<dt><strong><code>max_value</code></strong></dt>
<dd>Float maximum objective value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of two float values (lower_bound, upper_bound).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetImageObjectiveBounds(self, min_value, max_value):
    &#34;&#34;&#34;
    Return min and max bounds to be used for images.
    Images should use bounds that are slightly wider than observed
    objective values.  Also, the special case of a single value must be
    handled.
    Args:
      min_value: Float minimum objective value.
      max_value: Float maximum objective value.
    Returns:
      A tuple of two float values (lower_bound, upper_bound).
    &#34;&#34;&#34;
    obj_range = max_value - min_value
    if obj_range &gt; 0:
        image_max_obj = max_value + 0.01 * obj_range
        image_min_obj = min_value - 0.01 * obj_range
    else:
        if max_value &gt;= 0:
            image_max_obj = 1.01 * max_value
        else:
            image_max_obj = 0.99 * max_value
        if min_value &gt;= 0:
            image_min_obj = 0.99 * min_value
        else:
            image_min_obj = 1.01 * min_value
    return (image_min_obj, image_max_obj)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GetTreeFixedHorizontalPositions"><code class="name flex">
<span>def <span class="ident">GetTreeFixedHorizontalPositions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns horizontal positions for all nodes based on fixed positions.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary of float horizontal positions, keyed by node id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTreeFixedHorizontalPositions(self):
    &#34;&#34;&#34;
    Returns horizontal positions for all nodes based on fixed positions.
    Returns:
      Dictionary of float horizontal positions, keyed by node id.
    &#34;&#34;&#34;
    # Statistics needed for horizontal positions.
    horizontal_lower_bound = dict.fromkeys(self.get_node_list(), 0.0)
    horizontal_upper_bound = dict.fromkeys(self.get_node_list(), 1.0)
    horizontal_positions = dict.fromkeys(self.get_node_list())
    horizontal_positions[self.root.name] = 0.5
    # sort node list
    node_id_list = sorted(self.get_node_list())
    node_id_list_int = list(int(n) for n in node_id_list)
    node_id_list_int = sorted(node_id_list_int)
    node_id_list = list(str(n) for n in node_id_list_int)
    for node_id in node_id_list:
        if node_id == self.root.name:
            continue
        parent_id = self.get_node_attr(node_id, &#39;parent&#39;)
        branch_direction = self.get_node_attr(node_id, &#39;direction&#39;)
        if branch_direction == &#39;R&#39;:
            horizontal_lower_bound[node_id] = horizontal_positions[
                parent_id]
            horizontal_upper_bound[node_id] = horizontal_upper_bound[
                parent_id]
        elif branch_direction == &#39;L&#39;:
            horizontal_lower_bound[node_id] = horizontal_lower_bound[
                parent_id]
            horizontal_upper_bound[node_id] = horizontal_positions[
                parent_id]
        else:
            print(&#39;Error: node %s has unsupported branching direction.&#39;\
                %node_id)
            print(&#39;Fixed-position tree images only support L and R &#39;)
            print(&#39;branching.&#39;)
            sys.exit(1)
        horizontal_positions[node_id] = old_div((
            horizontal_upper_bound[node_id] +
            horizontal_lower_bound[node_id]), 2)
    return horizontal_positions</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.GetTreeHorizontalPositions"><code class="name flex">
<span>def <span class="ident">GetTreeHorizontalPositions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns horizontal positions for all nodes.
Each node is given equal horizontal space.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary of float horizontal positions, keyed by node id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTreeHorizontalPositions(self):
    &#34;&#34;&#34;
    Returns horizontal positions for all nodes.
    Each node is given equal horizontal space.
    Returns:
      Dictionary of float horizontal positions, keyed by node id.
    &#34;&#34;&#34;
    # Statistics needed for horizontal positions.
    number_descendants = dict.fromkeys(self.get_node_list(), 1)
    # number_descendants includes the key node itself
    horizontal_lower_bound = dict.fromkeys(self.get_node_list(), 0.0)
    horizontal_upper_bound = dict.fromkeys(self.get_node_list(), 1.0)
    horizontal_positions = dict.fromkeys(self.get_node_list())
    visited = dict.fromkeys(self.get_node_list(), False)
    # Count the number of descendants for each node.
    # Do a post-order traversal of the tree.
    node_stack = []
    node_stack.append(self.root.name)
    while node_stack:
        current_node = node_stack[len(node_stack) - 1]
        lchild = self.get_left_child(current_node)
        rchild = self.get_right_child(current_node)
        is_node_added = False
        # Add the next unvisited child to the stack
        if lchild is not None and not visited[quote(lchild)]:
            node_stack.append(lchild)
            is_node_added = True
        if (rchild is not None and not visited[quote(rchild)] and
            is_node_added==False):
            node_stack.append(rchild)
            is_node_added = True
        # If all childs visited, then update number_descendants
        if not is_node_added:
            if lchild is not None:
                number_descendants[quote(current_node)] += (
                            number_descendants[quote(lchild)])
            if rchild is not None:
                number_descendants[quote(current_node)] += (
                            number_descendants[quote(rchild)])
            visited[quote(current_node)] = True
            del node_stack[len(node_stack) - 1]
    # Traverse the tree and set horizontal positions.
    # Do a pre-order traversal of the tree.
    node_stack = []
    node_stack.append(self.root.name)
    horizontal_lower_bound[self.root.name] = 0.0
    horizontal_upper_bound[self.root.name] = 1.0
    while node_stack:
        node = node_stack.pop()
        lchild = self.get_left_child(node)
        rchild = self.get_right_child(node)
        direction = None
        number_of_children = 0
        children_list = []
        # Place all children on the stack
        if lchild is not None:
            node_stack.append(lchild)
            number_of_children += 1
            direction = &#39;L&#39;
            children_list.append(lchild)
        if rchild is not None:
            node_stack.append(rchild)
            number_of_children += 1
            direction = &#39;R&#39;
            children_list.append(rchild)
        # Convenience variables
        current_lower_bound = horizontal_lower_bound[quote(node)]
        current_range = (horizontal_upper_bound[quote(node)] -
                         horizontal_lower_bound[quote(node)])
        total_descendants = number_descendants[quote(node)]
        sorted_child_labels = sorted(children_list)
        # Determine where to place this node with respect to its children.
        # Put the node in the center, or have more children on the left.
        before_index = int(math.ceil(old_div(number_of_children,2.0)))
        # Exception with a single node that is &#39;L&#39;
        if number_of_children == 1:
            if direction != &#39;L&#39;:
                before_index = 0
        cumulative_descendants = 0
        for i, label in enumerate(sorted_child_labels):
            if before_index == i:
                # Determine the relative position for the current node
                relative_position = old_div((cumulative_descendants + 0.5), (
                    total_descendants))
                cumulative_descendants += 1
            # Set bounds for this child
            horizontal_lower_bound[quote(label)] = (
                current_lower_bound + float(cumulative_descendants) /
                total_descendants * current_range)
            # Increment cumulative_descendants, which also lets us compute
            # the upper bound.
            cumulative_descendants += number_descendants[quote(label)]
            horizontal_upper_bound[quote(label)] = (
                current_lower_bound + float(cumulative_descendants) /
                total_descendants * current_range)
        # Catch the case that the node comes after all its children.
        # This must also work for the case that this is the only node.
        if before_index == len(sorted_child_labels):
            relative_position = old_div((cumulative_descendants + 0.5), (
                total_descendants))
        # Finally set the position for the current node
        horizontal_positions[quote(node)] = (
            horizontal_lower_bound[quote(node)] + relative_position * (
                horizontal_upper_bound[quote(node)] -
                horizontal_lower_bound[quote(node)]))
    return horizontal_positions</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.IsBetterThan"><code class="name flex">
<span>def <span class="ident">IsBetterThan</span></span>(<span>self, value1, value2)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if value1 is better than value2 as an objective value.
This depends on the optimization sense of the instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value1</code></strong></dt>
<dd>Float.</dd>
<dt><strong><code>value2</code></strong></dt>
<dd>Float.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if value1 is better than value2 as an objective value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsBetterThan(self, value1, value2):
    &#34;&#34;&#34;
    Returns True if value1 is better than value2 as an objective value.
    This depends on the optimization sense of the instance.
    Args:
      value1: Float.
      value2: Float.
    Returns:
      True if value1 is better than value2 as an objective value.
    &#34;&#34;&#34;
    if self._optimization_sense is None:
        print(&#34;Optimization sense is not set, assuming sense is miniminzation&#34;)
        self._optimization_sense = &#39;min&#39;
    if self._optimization_sense == &#39;min&#39;:
        return value1 &lt; value2
    else:
        return value1 &gt; value2</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.IsBetterThanIncumbent"><code class="name flex">
<span>def <span class="ident">IsBetterThanIncumbent</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the passed value is better than current incumbent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Float to use for comparison.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the passed value is better than the current incumbent.
'Better' is determined by the sense of optimization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsBetterThanIncumbent(self, value):
    &#34;&#34;&#34;
    Returns True if the passed value is better than current incumbent.
    Args:
      value: Float to use for comparison.
    Returns:
      True if the passed value is better than the current incumbent.
      &#39;Better&#39; is determined by the sense of optimization.
    &#34;&#34;&#34;
    if self._incumbent_value is None:
        return True
    else:
        return self.IsBetterThan(value, self._incumbent_value)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessBranchedLine"><code class="name flex">
<span>def <span class="ident">ProcessBranchedLine</span></span>(<span>self, node_id, parent_id, branch_direction, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'branched'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>String node id.</dd>
<dt><strong><code>parent_id</code></strong></dt>
<dd>String node id of parent.</dd>
<dt><strong><code>branch_direction</code></strong></dt>
<dd>String of 'L' or 'R' indicating whether this node</dd>
<dt>is the left or right child of its parent.</dt>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessBranchedLine(self, node_id, parent_id, branch_direction,
                        remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;branched&#39;.
    Args:
      node_id: String node id.
      parent_id: String node id of parent.
      branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
      is the left or right child of its parent.
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Parse remaining tokens
    if len(remaining_tokens) not in [3, 5]:
        print(&#39;Invalid line: %s branched %s %s %s %s&#39; % (
                self._time, node_id, parent_id, branch_direction,
                &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; branched &lt;node id&gt; &lt;parent id&gt; &#39;)
        print(&#39;&lt;branch direction&gt; &lt;lp bound&gt; &#39;)
        print(&#39;&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
        print(&#39;infeasibilities&gt;&#39;)
        sys.exit(1)
    lp_bound = float(remaining_tokens[0])
    integer_infeasibility_sum = float(remaining_tokens[1])
    integer_infeasibility_count = int(remaining_tokens[2])
    condition_begin = None
    condition_end = None
    if len(remaining_tokens) == 5:
        # In this case, we must also be printing conditions numbers
        condition_begin = int(remaining_tokens[3])
        condition_end = int(remaining_tokens[4])
    self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;branched&#39;,
                         lp_bound, integer_infeasibility_count,
                         integer_infeasibility_sum, condition_begin,
                         condition_end)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessCandidateLine"><code class="name flex">
<span>def <span class="ident">ProcessCandidateLine</span></span>(<span>self, node_id, parent_id, branch_direction, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'candidate'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>String node id.</dd>
<dt><strong><code>parent_id</code></strong></dt>
<dd>String node id of parent.</dd>
<dt><strong><code>branch_direction</code></strong></dt>
<dd>String of 'L' or 'R' indicating whether this node</dd>
<dt>is the left or right child of its parent.</dt>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessCandidateLine(self, node_id, parent_id, branch_direction,
                         remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;candidate&#39;.
    Args:
      node_id: String node id.
      parent_id: String node id of parent.
      branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
      is the left or right child of its parent.
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Parse remaining tokens
    if len(remaining_tokens) == 2 or len(remaining_tokens) &gt; 3:
        print(&#39;Invalid line: %s branched %s %s %s %s&#39; % (
                self._time, node_id, parent_id, branch_direction,
                &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; candidate &lt;node id&gt; &lt;parent id&gt; &#39;)
        print(&#39;&lt;branch direction&gt; [&lt;lp bound&gt;] &#39;)
        print(&#39;[&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
        print(&#39;infeasibilities&gt;]&#39;)
        sys.exit(1)
    # if parent_id not in self.get_node_list():
    #     print &#39;Error: node %s not in set&#39; % parent_id
    #     sys.exit(1)
    # TODO(bhunsaker): Check that we handle the cases of updating a
    #candidate.
    if len(remaining_tokens) &gt; 0:
        lp_bound = float(remaining_tokens[0])
    else:
        lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
    if len(remaining_tokens) == 3:
        integer_infeasibility_sum = float(remaining_tokens[1])
        integer_infeasibility_count = int(remaining_tokens[2])
    else:
        integer_infeasibility_sum = self.get_node_attr(parent_id,
                                              &#39;integer_infeasibility_sum&#39;)
        integer_infeasibility_count = self.get_node_attr(parent_id,
                                            &#39;integer_infeasibility_count&#39;)
    self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;candidate&#39;,
                         lp_bound, integer_infeasibility_count,
                         integer_infeasibility_sum)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessFathomedLine"><code class="name flex">
<span>def <span class="ident">ProcessFathomedLine</span></span>(<span>self, node_id, parent_id, branch_direction, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'fathomed'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>String node id.</dd>
<dt><strong><code>parent_id</code></strong></dt>
<dd>String node id of parent.</dd>
<dt><strong><code>branch_direction</code></strong></dt>
<dd>String of 'L' or 'R' indicating whether this node is
the left or right child of its parent.</dd>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessFathomedLine(self, node_id, parent_id, branch_direction,
                        remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;fathomed&#39;.
    Args:
      node_id: String node id.
      parent_id: String node id of parent.
      branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
        the left or right child of its parent.
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Print a warning if there is no current incumbent.
    if self._incumbent_value is None:
        print(&#39;WARNING: Encountered &#34;fathom&#34; line before first incumbent.&#39;)
        print(&#39;  This may indicate an error in the input file.&#39;)
    # Parse remaining tokens
    if len(remaining_tokens) &gt; 1:
        print(&#39;Invalid line: %s fathomed %s %s %s %s&#39; % (
                self._time, node_id, parent_id, branch_direction,
                &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; fathomed &lt;node id&gt; &lt;parent id&gt;&#39;+\
            &#39;&lt;branch direction&gt; [&lt;lp bound&gt;]&#39;)
        sys.exit(1)
    if len(remaining_tokens) == 1:
        lp_bound = float(remaining_tokens[0])
    else:
        if (node_id in self.get_node_list() and
            self.get_node_attr(node_id, &#39;lp_bound&#39;) is not None):
            lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
        else:
            lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
        if self._optimization_sense == &#39;min&#39;:
            if (self._incumbent_value is not None and
                lp_bound &lt; self._incumbent_value):
                lp_bound = self._incumbent_value
        elif self._optimization_sense == &#39;max&#39;:
            if (self._incumbent_value is not None and
                lp_bound &gt; self._incumbent_value):
                lp_bound = self._incumbent_value
    parent_node = self.get_node(parent_id)
    self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;fathomed&#39;,
                         lp_bound,
                         self.get_node_attr(parent_id,
                                            &#39;integer_infeasibility_count&#39;),
                         self.get_node_attr(parent_id,
                                            &#39;integer_infeasibility_sum&#39;))</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessHeuristicLine"><code class="name flex">
<span>def <span class="ident">ProcessHeuristicLine</span></span>(<span>self, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'heuristic'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessHeuristicLine(self, remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;heuristic&#39;.
    Args:
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Parse remaining tokens
    if len(remaining_tokens) &lt; 1 or len(remaining_tokens) &gt; 2:
        print(&#39;Invalid line: %s heuristic %s&#39; % (
                self._time, &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; heuristic &lt;obj value&gt;&#39;+\
            &#39; [&lt;associated node id&gt;]&#39;)
        sys.exit(1)
    objective_value = float(remaining_tokens[0])
    if len(remaining_tokens) == 2:
        associated_node = remaining_tokens[1]
    else:
        associated_node = None
    # Check that this is actually an improvement
    if self._incumbent_value is not None and self._optimization_sense is None:
        if objective_value &gt; self._incumbent_value:
            print(&#34;Objective sense unset, guessing maximization&#34;)
            self._optimization_sense = &#39;max&#39;
        else:
            print(&#34;Objective sense unset, guessing minimization&#34;)
            self._optimization_sense = &#39;min&#39;
    if not self.IsBetterThanIncumbent(objective_value):
        return
    self._previous_incumbent_value = self._incumbent_value
    self._incumbent_value = objective_value
    self.UpdateObjectiveValueLimits(objective_value)
    self._incumbent_parent = associated_node
    # Set variable to generate images
    self._new_integer_solution = True</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessInfeasibleLine"><code class="name flex">
<span>def <span class="ident">ProcessInfeasibleLine</span></span>(<span>self, node_id, parent_id, branch_direction, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'infeasible'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>String node id.</dd>
<dt><strong><code>parent_id</code></strong></dt>
<dd>String node id of parent.</dd>
<dt><strong><code>branch_direction</code></strong></dt>
<dd>String of 'L' or 'R' indicating whether this node is
the left or right child of its parent.</dd>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessInfeasibleLine(self, node_id, parent_id, branch_direction,
                          remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;infeasible&#39;.
    Args:
      node_id: String node id.
      parent_id: String node id of parent.
      branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
        the left or right child of its parent.
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Parse remaining tokens
    if len(remaining_tokens) not in [0, 2]:
        print(&#39;Invalid line: %s infeasible %s %s %s %s&#39; % (
                self._time, node_id, parent_id, branch_direction,
                &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; infeasible &lt;node id&gt; &lt;parent id&gt; &#39;)
        print(&#39;&lt;branch direction&gt;&#39;)
        sys.exit(1)
    # Use parent values if the node does not have its own
    lp_bound = self.get_node_attr(parent_id, &#39;lp_bound&#39;)
    ii_count = self.get_node_attr(parent_id, &#39;integer_infeasibility_count&#39;)
    ii_sum = self.get_node_attr(parent_id, &#39;integer_infeasibility_sum&#39;)
    if node_id in self.get_node_list():
        if self.get_node_attr(node_id, &#39;lp_bound&#39;) is not None:
            lp_bound = self.get_node_attr(node_id, &#39;lp_bound&#39;)
        if (self.get_node_attr(node_id, &#39;integer_infeasibility_count&#39;)
            is not None):
            ii_count = self.get_node_attr(node_id,
                                          &#39;integer_infeasibility_count&#39;)
        if (self.get_node_attr(node_id, &#39;integer_infeasibility_sum&#39;)
            is not None):
            ii_sum = self.get_node_attr(node_id,&#39;integer_infeasibility_sum&#39;)
    if len(remaining_tokens) == 2:
        # In this case, we must also be printing conditions numbers
        condition_begin = int(remaining_tokens[0])
        condition_end = int(remaining_tokens[1])
    self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;infeasible&#39;,
                         lp_bound, ii_count, ii_sum)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessIntegerLine"><code class="name flex">
<span>def <span class="ident">ProcessIntegerLine</span></span>(<span>self, node_id, parent_id, branch_direction, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'integer'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>String node id.</dd>
<dt><strong><code>parent_id</code></strong></dt>
<dd>String node id of parent.</dd>
<dt><strong><code>branch_direction</code></strong></dt>
<dd>String of 'L' or 'R' indicating whether this node</dd>
<dt>is the left or right child of its parent.</dt>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessIntegerLine(self, node_id, parent_id, branch_direction,
                       remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;integer&#39;.
    Args:
      node_id: String node id.
      parent_id: String node id of parent.
      branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node
      is the left or right child of its parent.
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Parse remaining tokens
    if len(remaining_tokens) != 1:
        print(&#39;Invalid line: %s integer %s %s %s %s&#39; % (
                self._time, node_id, parent_id, branch_direction,
                &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; integer &lt;node id&gt; &lt;parent id&gt;&#39;+\
            &#39;&lt;branch direction&gt; &lt;obj value&gt;&#39;)
        sys.exit(1)
    objective_value = float(remaining_tokens[0])
    self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;integer&#39;,
                         objective_value, None, None)
    self._previous_incumbent_value = self._incumbent_value
    self._incumbent_value = objective_value
    self._incumbent_parent = parent_id
    self._new_integer_solution = True</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessLine"><code class="name flex">
<span>def <span class="ident">ProcessLine</span></span>(<span>self, line)</span>
</code></dt>
<dd>
<div class="desc"><p>Process a line of the input file, generating images if appropriate.
Parses the line, updates internal data structures, and creates images
if appropriate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>line</code></strong></dt>
<dd>String input line to process.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessLine(self, line):
    &#34;&#34;&#34;
    Process a line of the input file, generating images if appropriate.
    Parses the line, updates internal data structures, and creates images
    if appropriate.
    Args:
      line: String input line to process.
    &#34;&#34;&#34;
    line = line.strip()
    # Comments start with a &#39;#&#39;
    if line[0] == &#39;#&#39;:
        return
    tokens = line.split()
    if len(tokens) &lt; 3:
        print(&#39;Incomplete or invalid line: %s&#39; %&#39; &#39;.join(tokens))
        sys.exit(1)
    # Tokens shared by all line types
    self._time = float(tokens[0])
    line_type = tokens[1]
    remaining_tokens = tokens[2:]
    # Process the line based on the type
    if line_type == &#39;heuristic&#39;:
        self._optimal_soln_time = self._time
        self.ProcessHeuristicLine(remaining_tokens)
    else:
        # Other node types share common tokens
        node_id = int(tokens[2])
        parent_id = int(tokens[3])
        branch_direction = tokens[4]
        remaining_tokens = tokens[5:]
        # TODO(aykut):parent id of root node is 0 when we read from file.
        if id==self.root:
            parent_id = None
        # Check that the parent node id is valid
        # elif parent_id not in self.get_node_list() and self.root is not None:
        #     print &#39;Parent id does not exist: %s&#39; % line
        #     sys.exit(1)
        if line_type == &#39;integer&#39;:
            self._optimal_soln_time = self._time
            self.ProcessIntegerLine(node_id, parent_id,
                                    branch_direction, remaining_tokens)
        elif line_type == &#39;fathomed&#39;:
            self.ProcessFathomedLine(node_id, parent_id,
                                     branch_direction, remaining_tokens)
        elif line_type == &#39;candidate&#39;:
            self.ProcessCandidateLine(node_id, parent_id,
                                      branch_direction, remaining_tokens)
        elif line_type == &#39;pregnant&#39;:
            self.ProcessPregnantLine(node_id, parent_id,
                                     branch_direction, remaining_tokens)
        elif line_type == &#39;branched&#39;:
            self.ProcessBranchedLine(node_id, parent_id,
                                     branch_direction, remaining_tokens)
        elif line_type == &#39;infeasible&#39;:
            self.ProcessInfeasibleLine(node_id, parent_id,
                                       branch_direction, remaining_tokens)
        else:
            print(&#39;Unexpected line type &#34;%s&#34;: %s&#39; % (line_type,
                                                     &#39; &#39;.join(tokens)))
            sys.exit(1)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.ProcessPregnantLine"><code class="name flex">
<span>def <span class="ident">ProcessPregnantLine</span></span>(<span>self, node_id, parent_id, branch_direction, remaining_tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>Core processing for a line of type 'pregnant'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong></dt>
<dd>String node id.</dd>
<dt><strong><code>parent_id</code></strong></dt>
<dd>String node id of parent.</dd>
<dt><strong><code>branch_direction</code></strong></dt>
<dd>String of 'L' or 'R' indicating whether this node is
the left or right child of its parent.</dd>
<dt><strong><code>remaining_tokens</code></strong></dt>
<dd>List of string tokens. These are those that remain
after any common tokens are processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProcessPregnantLine(self, node_id, parent_id, branch_direction,
                        remaining_tokens):
    &#34;&#34;&#34;
    Core processing for a line of type &#39;pregnant&#39;.
    Args:
      node_id: String node id.
      parent_id: String node id of parent.
      branch_direction: String of &#39;L&#39; or &#39;R&#39; indicating whether this node is
        the left or right child of its parent.
      remaining_tokens: List of string tokens. These are those that remain
        after any common tokens are processed.
    &#34;&#34;&#34;
    # Parse remaining tokens
    if len(remaining_tokens) != 3:
        print(&#39;Invalid line: %s pregnant %s %s %s %s&#39; % (
                self._time, node_id, parent_id, branch_direction,
                &#39; &#39;.join(remaining_tokens)))
        print(&#39;Should match: &lt;time&gt; pregnant &lt;node id&gt; &lt;parent id&gt; &#39;)
        print(&#39;&lt;branch direction&gt; &lt;lp bound&gt; &#39;)
        print(&#39;&lt;sum of integer infeasibilities&gt; &lt;number of integer &#39;)
        print(&#39;infeasibilities&gt;&#39;)
        sys.exit(1)
    lp_bound = float(remaining_tokens[0])
    integer_infeasibility_sum = float(remaining_tokens[1])
    integer_infeasibility_count = int(remaining_tokens[2])

    self.AddOrUpdateNode(node_id, parent_id, branch_direction, &#39;pregnant&#39;,
                         lp_bound, integer_infeasibility_count,
                         integer_infeasibility_sum)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.RunGnuplotOnAllFiles"><code class="name flex">
<span>def <span class="ident">RunGnuplotOnAllFiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs Gnuplot on all files in self._gnuplot_files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunGnuplotOnAllFiles(self):
    &#34;&#34;&#34;Runs Gnuplot on all files in self._gnuplot_files.&#34;&#34;&#34;
    for file in self._gnuplot_files:
        subprocess.call([&#39;gnuplot&#39;, file])</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.UpdateObjectiveValueLimits"><code class="name flex">
<span>def <span class="ident">UpdateObjectiveValueLimits</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the min and max objective values if appropriate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Float objective value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateObjectiveValueLimits(self, value):
    &#34;&#34;&#34;Updates the min and max objective values if appropriate.
    Args:
      value: Float objective value.
    &#34;&#34;&#34;
    if self._max_objective_value is None:
        self._max_objective_value = value
        self._min_objective_value = value
    else:
        if value &gt; self._max_objective_value:
            self._max_objective_value = value
        if value &lt; self._min_objective_value:
            self._min_objective_value = value</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.WriteAllIncumbentPathsScript"><code class="name flex">
<span>def <span class="ident">WriteAllIncumbentPathsScript</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Gnuplot script string to generate an incumbent path image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_filenames</code></strong></dt>
<dd>List of string names of files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteAllIncumbentPathsScript(self):
    &#34;&#34;&#34;
    Return a Gnuplot script string to generate an incumbent path image.
    Args:
      data_filenames: List of string names of files.
    &#34;&#34;&#34;
    data_filenames = self._incumbent_path_datafiles
    image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
        self._scatterplot_lower_bound, self._scatterplot_upper_bound)
    script = &#39;&#39;
    # Set terminal for the output files.
    script += &#39;set terminal png notransparent size 480,360\n\n&#39;

    # Make settings for the scatter plot.
    if self._filename is None:
        script += &#39;set title &#34;Incumbent paths&#34;\n&#39;
    else:
        script += (&#39;set title &#34;Incumbent paths (%s %.2fs %s)&#34;\n&#39; % (
                self._filename, self._time, self._label))
    script += &#39;set pointsize 0.8\n&#39;
    script += &#39;set nokey\n&#39;
    script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
    script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
    script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                      self._max_integer_infeasibility_sum)
    script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                      image_max_obj))
    # Plot the data points and connecting lines.
    command_list = []
    for filename in data_filenames:
        command_list.append(&#39;\&#39;%s\&#39; with points pointtype 2, &#39;
                            &#39;\&#39;%s\&#39; with lines linetype 2&#39; %
                            (filename, filename))
    script += &#39;plot %s\n&#39; % &#39;,&#39;.join(command_list)
    script += &#39;show output\n&#39;
    return script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.WriteDataFileFromList"><code class="name flex">
<span>def <span class="ident">WriteDataFileFromList</span></span>(<span>self, filename, data_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a list of string data to a file with one entry per line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>String filename to open.</dd>
<dt><strong><code>data_list</code></strong></dt>
<dd>List of string values to write.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteDataFileFromList(self, filename, data_list):
    &#34;&#34;&#34;
    Write a list of string data to a file with one entry per line.
    Args:
      filename: String filename to open.
      data_list: List of string values to write.
    &#34;&#34;&#34;
    outfile = open(filename, &#39;w&#39;)
    for line in data_list:
        outfile.write(line)
    outfile.close()</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.WriteHistogramScript"><code class="name flex">
<span>def <span class="ident">WriteHistogramScript</span></span>(<span>self, num_bins, bin_width, max_bin_count, lp_bound, data_filename, output_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a Gnuplot script file to generate a histogram image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_bins</code></strong></dt>
<dd>Integer number of bins for the histogram.</dd>
<dt><strong><code>bin_width</code></strong></dt>
<dd>Float width of the bins in terms of objective values.</dd>
<dt><strong><code>max_bin_count</code></strong></dt>
<dd>Integer number of the highest bin count.</dd>
<dt><strong><code>lp_bound</code></strong></dt>
<dd>Float value of the current LP bound.</dd>
<dt><strong><code>data_filename</code></strong></dt>
<dd>String name of the file; used for display purposes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteHistogramScript(self, num_bins, bin_width, max_bin_count,
                             lp_bound, data_filename, output_file):
    &#34;&#34;&#34;
    Write a Gnuplot script file to generate a histogram image.
    Args:
      num_bins: Integer number of bins for the histogram.
      bin_width: Float width of the bins in terms of objective values.
      max_bin_count: Integer number of the highest bin count.
      lp_bound: Float value of the current LP bound.
      data_filename: String name of the file; used for display purposes.
    &#34;&#34;&#34;
    # TODO(bhunsaker): add checks for bin_width zero
    if self._incumbent_value is not None:
        incumbent_bin = 1 + ((self._incumbent_value -
                              self._histogram_lower_bound) // bin_width)
        incumbent_x_coord = 0.5 + (old_div((self._incumbent_value -
                                    self._histogram_lower_bound),
                                   bin_width))
    lp_bound_bin = 1 + ((lp_bound - self._histogram_lower_bound) //
                        bin_width)
    lp_bound_x_coord = 0.5 + (old_div((lp_bound - self._histogram_lower_bound),
                              bin_width))
    # TODO(bhunsaker): Ask Osman about adjust_xcoord option, which appears
    #    to put the vertical lines at the edge of bins rather than the
    #    true location.
    # Output the Gnuplot script to a file.
    script = &#34;&#34;
    # Set terminal for the output files.
    script += &#39;set terminal png notransparent size 480,360\n\n&#39;
    # Make settings for the scatter plot.
    index_string = self.GetImageCounterString()
    output_filename = &#34;histogram.&#34;+index_string+&#34;.png&#34;
    if output_file:
        script += &#39;set output &#34;%s&#34;\n&#39; % output_filename
    if self._filename is None:
        script += &#39;set title &#34;Histogram of LP Bounds&#34;\n&#39;
    else:
        script += (&#39;set title &#34;Histogram of LP Bounds: %s, %s, %.2fs&#34;\n&#39;
                   % (self._filename, self._label, self._time))
    script += &#39;set xlabel &#34;obj. value&#34;\n&#39;
    script += &#39;set ylabel &#34;number of nodes&#34;\n&#39;
    if self._logscaley:
        script += &#39;set logscale y\n&#39;
    script += &#39;set nokey\n&#39;
    script += &#39;set tics scale 0.001\n&#39;

    script += &#39;set xrange [0:%d+1]\n&#39; % num_bins
    if self._logscaley:
        script += &#39;set yrange [1:%d*1.2]\n&#39; % max_bin_count
    else:
        script += &#39;set yrange [0:%d*1.2]\n&#39; % max_bin_count
    script += &#39;set xtics rotate by 90\n&#39;
    # Mark tics for each bin.
    script += &#39;set xtics (&#39;
    # TODO(bhunsaker): Consider putting this in a loop.
    x_values = [&#39;&#34;%0.2f&#34; %0.2f&#39; %
                (self._histogram_lower_bound + i * bin_width, i + 0.5)
                for i in range(num_bins + 1)]
    script += &#39;, &#39;.join(x_values) + &#39;)\n&#39;
    # Plot LP bound and incumbent tics.
    script += &#39;set x2tics (&#39;
    script += &#39;&#34;%0.2f&#34; %d&#39; % (lp_bound, lp_bound_bin)
    if self._incumbent_value is not None:
        script += &#39;, &#34;%0.2f&#34;%d)\n&#39; % (self._incumbent_value,
                                              incumbent_bin)
    else:
        script += &#39;)\n&#39;
    plot_parts = []
    # Plot the data points.
    plot_parts.append(&#39;\&#39;%s\&#39; with boxes fill solid 0.2&#39; % data_filename)
    # Draw the vertical lp_bound and incumbent lines.
    script += &#39;set parametric\n&#39;
    script += &#39;set trange [0:%d*1.5]\n&#39; % max_bin_count
    plot_parts.append(&#39;%0.2f,t linetype 2&#39; % lp_bound_x_coord)
    if self._incumbent_value is not None:
        plot_parts.append(&#39;%0.2f,t linetype 5&#39; % incumbent_x_coord)
    script += &#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts)
    script += &#39;unset parametric\n&#39;
    script += &#39;show output\n&#39;
    return script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.WriteIncumbentPathScript"><code class="name flex">
<span>def <span class="ident">WriteIncumbentPathScript</span></span>(<span>self, data_filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a Gnuplot script file to generate an incumbent path image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_filename</code></strong></dt>
<dd>String name of the file; used for display purposes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteIncumbentPathScript(self, data_filename):
    &#34;&#34;&#34;
    Write a Gnuplot script file to generate an incumbent path image.
    Args:
      data_filename: String name of the file; used for display purposes.
    &#34;&#34;&#34;
    image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
        self._scatterplot_lower_bound, self._scatterplot_upper_bound)
    script = &#39;&#39;
    # Set terminal for the output files.
    script += &#39;set terminal png notransparent size 480,360\n\n&#39;
    if self._filename is None:
        script += &#39;set title &#34;Incumbent path&#34;\n&#39;
    else:
        script += (&#39;set title &#34;Incumbent path (%s %.2fs %s)&#34;\n&#39; % (
                self._filename, self._time, self._label))
    script += &#39;set pointsize 0.8\n&#39;
    script += &#39;set nokey\n&#39;
    script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
    script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
    script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                      self._max_integer_infeasibility_sum)
    script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                      image_max_obj))
    # Plot the data points and connecting lines.
    script += (&#39;plot \&#39;%s\&#39; with points pointtype 2, &#39;
                      &#39;\&#39;%s\&#39; with lines linetype 2\n&#39; %
                      (data_filename, data_filename))
    script += &#39;show output\n&#39;
    return script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.WriteScatterplotScript"><code class="name flex">
<span>def <span class="ident">WriteScatterplotScript</span></span>(<span>self, data_filename, output_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a Gnuplot script file to generate a scatterplot image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_filename</code></strong></dt>
<dd>String name of the file; used for display purposes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteScatterplotScript(self, data_filename, output_file):
    &#34;&#34;&#34;
    Write a Gnuplot script file to generate a scatterplot image.
    Args:
      data_filename: String name of the file; used for display purposes.
    &#34;&#34;&#34;
    image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
        self._scatterplot_lower_bound, self._scatterplot_upper_bound)
    index_string = self.GetImageCounterString()
    output_filename = &#34;scatterplot.&#34;+index_string+&#34;.png&#34;
    script = &#34;&#34;
    # Set terminal for the output files.
    script += &#39;set terminal png notransparent size 480,360\n\n&#39;
    # Make settings for the scatter plot.
    if output_file:
        script += &#39;set output &#34;%s&#34;\n&#39; % output_filename
    if self._filename is None:
        script += &#39;set title &#34;Scatterplot&#34;\n&#39;
    else:
        script += (&#39;set title &#34;Scatterplot: %s, %s, %ds&#34;\n&#39; % (
                self._filename, self._label, int(self._time)))
    script += &#39;set pointsize 0.8\n&#39;
    script += &#39;set nokey\n&#39;
    script += &#39;set xlabel \&#34;sum of int. infeas.\&#34;\n&#39;
    script += &#39;set ylabel \&#34;obj. value\&#34;\n&#39;
    script += (&#39;set xrange [0:%0.6f+2]\n&#39; %
                      self._max_integer_infeasibility_sum)
    script += (&#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_min_obj,
                                                      image_max_obj))
    plot_parts = []
    # Plot the data points.
    plot_parts.append(&#39;\&#39;%s\&#39; with points pointtype 2 linetype 1&#39; %
                      data_filename)
    # Also plot the incumbent line.
    if self._incumbent_value is not None:
        plot_parts.append(&#39;%0.6f linetype 2 linewidth 0.5&#39; %
                          self._incumbent_value)
    # Plot the incumbent&#39;s parent if it&#39;s available.
    if self._incumbent_parent is not None:
        #incumbent_parent = self.get_node(self._incumbent_parent)
        plot_parts.append(&#39;&#34;&lt; echo %0.6f %0.6f&#34; &#39;
                          &#39;with points pointtype 9 pointsize 1.2&#39; %
                          (self.get_node_attr(self._incumbent_parent,
                                              &#39;integer_infeasibility_sum&#39;),
                           self.get_node_attr(self._incumbent_parent,
                                              &#39;lp_bound&#39;)))
    script += &#39;plot %s\n&#39; % &#39;, &#39;.join(plot_parts)
    script += &#39;show output\n&#39;
    return script</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.WriteTreeScript"><code class="name flex">
<span>def <span class="ident">WriteTreeScript</span></span>(<span>self, additional_lines=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a Gnuplot script file to generate a tree image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>additional_lines</code></strong></dt>
<dd>String with additional lines to be added to the
script file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteTreeScript(self, additional_lines = None):
    &#34;&#34;&#34;
    Write a Gnuplot script file to generate a tree image.
    Args:
      additional_lines: String with additional lines to be added to the
        script file.
    &#34;&#34;&#34;
    image_min_obj, image_max_obj = self.GetImageObjectiveBounds(
        self._min_objective_value, self._max_objective_value)
    data = &#39;&#39;
    data += &#39;set terminal png notransparent size 480,360\n&#39;
    data += &#39;set output &#34;%s&#34;\n&#39; % output_file
    data += &#39;set nokey\n&#39;
    data += &#39;set autoscale\n&#39;
    data += &#39;set tics scale 0.001\n&#39;
    data += &#39;set pointsize 0.5\n&#39;
    data += &#39;set xrange [-0.1:1.1]\n&#39;
    data += &#39;set yrange [%0.6f:%0.6f]\n&#39; % (image_max_obj,
                                                      image_min_obj)
    data += &#39;set format x &#34;&#34;\n&#39;
    data += &#39;set ylabel &#34;obj. value&#34;\n&#39;
    if self._filename is None:
        data += &#39;set title &#34;B&amp;B tree&#34;\n&#39;
    else:
        data += &#39;set title &#34;B&amp;B tree (%s %.2fs %s)&#34;\n\n&#39; % (
            self._filename, self._time, self._label)
    for line in additional_lines:
        data += line
    return data</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self, item='all', basename='graph', format='png', count=None, pause=False, wait_for_click=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays/Saves images requested. BranchAndBound method calls this method
to visualize the branch and bound tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self, item = &#39;all&#39;, basename = &#39;graph&#39;, format=&#39;png&#39;,
            count=None, pause=False, wait_for_click=True):
    &#39;&#39;&#39;
    Displays/Saves images requested. BranchAndBound method calls this method
    to visualize the branch and bound tree.
    &#39;&#39;&#39;
    if self.attr[&#39;layout&#39;] != &#39;bak&#39;:
        if &#39;init_log_cond&#39; in self.root.attr:
            max_log_cond = 0
            for n in list(self.nodes.values()):
                if &#39;init_log_cond&#39; in n.attr:
                    max_log_cond = max(n.attr[&#39;init_log_cond&#39;], max_log_cond)
            for n in list(self.nodes.values()):
                if &#39;init_log_cond&#39; in n.attr:
                    log_begin = n.attr[&#39;init_log_cond&#39;]
                    log_end = n.attr[&#39;final_log_cond&#39;]
                    normalized_cond = (1-old_div(log_begin,max_log_cond))
                    color = str(hex(int(normalized_cond*256))[2:]) if normalized_cond &gt;= .0625 else &#39;0&#39; + str(hex(int(normalized_cond*256))[2:])
                    n.attr[&#39;label&#39;] = &#39;%.0f \n %.0f&#39; % (log_begin, log_end)
                    n.attr[&#39;color&#39;] = &#39;#&#39; + color*3
                    n.attr[&#39;fillcolor&#39;] = &#39;#&#39; + color*3
                    n.attr[&#39;style&#39;] = &#39;filled&#39;
                else:
                    n.attr[&#39;label&#39;] = &#39; &#39;
        BinaryTree.display(self, pause = pause, wait_for_click = wait_for_click)
        return
    if self.attr[&#39;display&#39;] is &#39;off&#39;:
        return
    if self.attr[&#39;display&#39;] is &#39;matplotlib&#39;:
        gnuplot_script = None
        if item==&#39;all&#39;:
            self.display_all()
        elif item==&#39;tree&#39;:
            gnuplot_script = self.GenerateTreeImage()
        elif item==&#39;scatterplot&#39;:
            gnuplot_script = self.GenerateScatterplot()
        elif item==&#39;histogram&#39;:
            gnuplot_script = self.GenerateHistogram()
        elif item==&#39;incumbent&#39;:
            gnuplot_script = self.GenerateIncumbentPath()
        elif item==&#39;forecast&#39;:
            gnuplot_script = self.GenerateForecastImages()
        else:
            raise Exception(&#39;Unknown display() method argument %s&#39; %item)
        if gnuplot_script is not None:
            self.display_image(gnuplot_script)
        # clean auxilary files.
        histogram_files = [f for f in os.listdir(&#34;.&#34;)
                           if f.startswith(&#34;histogram&#34;)]
        incumbent_files = [f for f in os.listdir(&#34;.&#34;)
                           if f.startswith(&#34;incumbentpath&#34;)]
        scatterplot_files = [f for f in os.listdir(&#34;.&#34;)
                             if f.startswith(&#34;scatterplot&#34;)]
        t_fathomed_files = [f for f in os.listdir(&#34;.&#34;)
                            if f.startswith(&#34;tree_fathomed&#34;)]
        t_infeasible_files = [f for f in os.listdir(&#34;.&#34;)
                            if f.startswith(&#34;tree_infeasible&#34;)]
        t_pregnant_files = [f for f in os.listdir(&#34;.&#34;)
                            if f.startswith(&#34;tree_pregnant&#34;)]
        t_integer_files = [f for f in os.listdir(&#34;.&#34;)
                           if f.startswith(&#34;tree_integer&#34;)]
        t_branched_files = [f for f in os.listdir(&#34;.&#34;)
                           if f.startswith(&#34;tree_branched&#34;)]
        bak_filelist = (histogram_files + incumbent_files +
                        scatterplot_files + t_fathomed_files +
                        t_integer_files + t_branched_files +
                        t_infeasible_files + t_pregnant_files)
        for f in bak_filelist:
            os.remove(f)
    elif self.attr[&#39;display&#39;] is &#39;xdot&#39;:
        if XDOT_INSTALLED:
            window = xdot.DotWindow()
            window.set_dotcode(self.to_string())
            window.connect(&#39;destroy&#39;, gtk.main_quit)
            gtk.main()
        else:
            print(&#39;Error: xdot not installed. Display disabled.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    elif self.attr[&#39;display&#39;] is &#39;file&#39;:
        if count is not None:
            basename = basename + &#39;_&#39; + str(count)
        if self.attr[&#39;layout&#39;] is &#39;dot2tex&#39;:
            if DOT2TEX_INSTALLED:
                if format != &#39;pdf&#39; or format != &#39;ps&#39;:
                    print(&#34;Dot2tex only supports pdf and ps formats,&#34;+\
                        &#34;falling back to pdf&#34;)
                    format = &#39;pdf&#39;
                self.set_layout(&#39;dot&#39;)
                tex = dot2tex.dot2tex(self.to_string(), autosize=True,
                                      texmode = &#39;math&#39;,
                                      template = DOT2TEX_TEMPLATE)
                f = open(basename+&#39;.tex&#39;, &#39;w&#39;)
                f.write(tex)
                f.close()
                subprocess.call([&#39;latex&#39;, basename])
                if format == &#39;ps&#39;:
                    subprocess.call([&#39;dvips&#39;, basename])
                elif format == &#39;pdf&#39;:
                    subprocess.call([&#39;pdflatex&#39;, basename])
                self.set_layout(&#39;dot2tex&#39;)
                # clean auxilary files.
                aux_filelist = [basename+&#39;.tex&#39;, basename+&#39;.log&#39;,
                                basename+&#39;.dvi&#39;, basename+&#39;.aux&#39;]
                for f in aux_filelist:
                    os.remove(f)
            else:
                print(&#34;Dot2tex not installed, falling back to graphviz&#34;)
                self.set_layout(&#39;dot&#39;)
                self.write(basename+&#39;.&#39;+format, self.get_layout(), format)
        else:
            gnuplot_script = None
            if item==&#39;all&#39;:
                self.display_all()
            elif item==&#39;tree&#39;:
                gnuplot_script = self.GenerateTreeImage()
            elif item==&#39;scatterplot&#39;:
                gnuplot_script = self.GenerateScatterplot()
            elif item==&#39;histogram&#39;:
                gnuplot_script = self.GenerateHistogram()
            elif item==&#39;incumbent&#39;:
                gnuplot_script = self.GenerateIncumbentPath()
            elif item==&#39;forecast&#39;:
                gnuplot_script = self.GenerateForecastImages()
            else:
                raise Exception(&#39;Unknown display() method argument %s&#39; %item)
            if gnuplot_script is not None:
                self.write_image(gnuplot_script, basename+&#39;.&#39;+format)
            # clean auxilary files.
            histogram_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;histogram&#34;)]
            incumbent_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;incumbentpath&#34;)]
            scatterplot_files = [f for f in os.listdir(&#34;.&#34;)
                                 if f.startswith(&#34;scatterplot&#34;)]
            t_fathomed_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_fathomed&#34;)]
            t_infeasible_files = [f for f in os.listdir(&#34;.&#34;)
                                  if f.startswith(&#34;tree_infeasible&#34;)]
            t_pregnant_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_pregnant&#34;)]
            t_integer_files = [f for f in os.listdir(&#34;.&#34;)
                               if f.startswith(&#34;tree_integer&#34;)]
            t_branched_files = [f for f in os.listdir(&#34;.&#34;)
                                if f.startswith(&#34;tree_branched&#34;)]
            bak_filelist = (histogram_files + incumbent_files +
                            scatterplot_files + t_fathomed_files +
                            t_integer_files + t_branched_files +
                            t_infeasible_files + t_pregnant_files)
            for f in bak_filelist:
                os.remove(f)
    else:
        raise Exception(&#39;Unknown display mode %s&#39; %self.attr[&#39;display&#39;])</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.display_all"><code class="name flex">
<span>def <span class="ident">display_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Assumes all the images have the same size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_all(self):
    &#39;&#39;&#39;
    Assumes all the images have the same size.
    &#39;&#39;&#39;
    print (&#39;This function is deprected and no longer functions&#39;)
    return</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.display_image"><code class="name flex">
<span>def <span class="ident">display_image</span></span>(<span>self, gnuplot_script, pause=False, wait_for_click=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_image(self, gnuplot_script, pause = False, wait_for_click = True):

    if not (PIL_INSTALLED and MATPLOTLIB_INSTALLED):
        print(&#39;Warning: Either matplotlib or Pillow is not installed. Cannot display.&#39;)
        return
    
    tmp_fd, tmp_name = tempfile.mkstemp()
    tmp_file = os.fdopen(tmp_fd, &#39;w+b&#39;)
    self.write_image(gnuplot_script, tmp_file)
    tmp_file.close()
    im = PIL_Image.open(tmp_name)
    plt.figure(1)
    plt.clf()
    plt.axis(&#39;off&#39;)
    plt.imshow(im, interpolation=&#39;bilinear&#39; #resample=True
               #extent = (0, 100, 0, 100)
    )
    if wait_for_click == True:
        plt.draw()
        try:
            if plt.waitforbuttonpress(timeout = 10000):
                plt.close()
                exit()
        except:
            exit()
    else:
        plt.show(block=pause)
    im.close()</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.process_file"><code class="name flex">
<span>def <span class="ident">process_file</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_file(self, file_name):
    self._filename = file_name
    input_file = open(file_name, &#39;r&#39;)
    # Parse all the lines
    for line in input_file:
        self.ProcessLine(line)
        if self.root is not None:
            self.display()
    input_file.close()</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, mode)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="api">Api</h2>
<p>set_display_mode(self, value)</p>
<h2 id="description">Description</h2>
<p>Sets display mode to value.</p>
<h2 id="input">Input</h2>
<p>value: New display mode.</p>
<h2 id="post">Post</h2>
<p>Display mode attribute of graph is updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_display_mode(self, mode):
    if mode is &#39;off&#39;:
        self.attr[&#39;display&#39;] = mode
    elif mode is &#39;matplotlib&#39;:
        if MATPLOTLIB_INSTALLED:
            self.attr[&#39;display&#39;] = &#39;matplotlib&#39;
        else:
            print(&#39;Matplotlib is not installed. Display is set to off.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    elif mode is &#39;PIL&#39;:
        if PIL_INSTALLED:
            self.attr[&#39;display&#39;] = &#39;PIL&#39;
        else:
            print(&#39;PIL is not installed. Display is set to off.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    elif mode is &#39;xdot&#39;:
        if XDOT_INSTALLED:
            self.attr[&#39;display&#39;] = &#39;xdot&#39;
        else:
            print(&#39;Xdot is not installed. Display is set to off.&#39;)
            self.attr[&#39;display&#39;] = &#39;off&#39;
    elif mode is &#39;file&#39;:
        self.attr[&#39;display&#39;] = &#39;file&#39;
    elif mode is &#39;matplotlib&#39;:
        self.attr[&#39;display&#39;] = &#39;matplotlib&#39;
    else:
        raise Exception(&#39;%s is not a valid display mode.&#39; %mode)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.set_edge_limit"><code class="name flex">
<span>def <span class="ident">set_edge_limit</span></span>(<span>self, limit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edge_limit(self, limit):
    self._edge_limit = limit</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.set_fathom"><code class="name flex">
<span>def <span class="ident">set_fathom</span></span>(<span>self, boolean)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fathom(self, boolean):
    self._fathom = boolean</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.set_label"><code class="name flex">
<span>def <span class="ident">set_label</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_label(self, label):
    self._label = label</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.set_logscaley"><code class="name flex">
<span>def <span class="ident">set_logscaley</span></span>(<span>self, boolean)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_logscaley(self, boolean):
    self._logscaley = boolean</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.set_sample_tree"><code class="name flex">
<span>def <span class="ident">set_sample_tree</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sample_tree(self, number):
    self._sample_tree = number</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.write_as_dynamic_gexf"><code class="name flex">
<span>def <span class="ident">write_as_dynamic_gexf</span></span>(<span>self, filename, mode='Dot')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_as_dynamic_gexf(self, filename, mode = &#34;Dot&#34;):
    if not GEXF_INSTALLED:
        print(&#39;Gexf not installed. Exiting.&#39;)
        return
    if mode == &#39;Dot&#39;:
        try:
            gexf = Gexf(&#34;Mike O&#39;Sullivan&#34;, &#34;Dynamic graph file&#34;)
            graph = gexf.addGraph(&#34;directed&#34;, &#34;dynamic&#34;, &#34;Dynamic graph&#34;)
            objAtt = graph.addNodeAttribute(&#34;obj&#34;, &#34;0.0&#34;, &#34;float&#34;)
            currAtt = graph.addNodeAttribute(&#34;current&#34;, &#34;1.0&#34;,
                                             &#34;integer&#34;, &#34;dynamic&#34;)
            node_names = self.get_node_list()
            for name in node_names:
                node = self.get_node(name)
                if node.get(&#34;step&#34;) is None:
                    raise Exception(&#34;Node without step in BBTree&#34;,
                                    &#34;node =&#34;, node)
                curr_step = &#39;%s&#39; % node.get(&#34;step&#34;)
                next_step = &#34;%s&#34; % (node.get(&#34;step&#34;) + 1)
                n = graph.addNode(name, node.get_label(), start=curr_step)
                if node.get(&#34;obj&#34;) is None:
                    raise Exception(&#34;Node without objective in BBTree&#34;,
                                    &#34;node =&#34;, node)
                n.addAttribute(objAtt, &#34;%s&#34; % node.get(&#34;obj&#34;))
                n.addAttribute(currAtt, &#34;1&#34;, start=curr_step, end=next_step)
                n.addAttribute(currAtt, &#34;0&#34;, start=next_step)
            edge_names = self.get_edge_list()
            for i, (m_name, n_name) in enumerate(edge_names):
                edge = self.get_edge(m_name, n_name)
                if edge.get(&#34;step&#34;) is None:
                    raise Exception(&#34;Edge without step in BBTree&#34;,
                                    &#34;edge =&#34;, (m_name, n_name))
                curr_step = &#34;%s&#34; % edge.get(&#34;step&#34;)
                graph.addEdge(i, m_name, n_name, start=curr_step)
            output_file = open(filename + &#34;.gexf&#34;, &#34;w&#34;)
            gexf.write(output_file)
        except Exception as e:
            print(e)
            print(&#34;No .gexf file created&#34;)
    else:
        raise Exception(&#34;Only Dot mode supported in write_as_dynamic_gexf&#34;)</code></pre>
</details>
</dd>
<dt id="coinor.grumpy.BBTree.BBTree.write_image"><code class="name flex">
<span>def <span class="ident">write_image</span></span>(<span>self, gnuplot_script, filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def write_image(self, gnuplot_script, filename):
        if not (MATPLOTLIB_INSTALLED and PIL_INSTALLED):
            print(&#39;Either matplotlib or Pillow is not installed. Display disabled&#39;)
            return
        try:
            p = subprocess.run([&#39;gnuplot&#39;], capture_output = True,
                               input = bytearray(gnuplot_script, &#39;utf8&#39;))
        except OSError:
            print(&#39;&#39;&#39;Gnuplot executable not found.
Gnuplot must be installed and in your search path.
After installation, ensure that the PATH variable is properly set.&#39;&#39;&#39;)
            return
        p.check_returncode()

        if p.stderr:
            print(p.stderr)        

        if isinstance(filename, str):
            with open(filename, &#34;w+b&#34;) as f:
                f.write(p.stdout)
        else:
            filename.write(p.stdout)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="coinor.grumpy" href="index.html">coinor.grumpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="coinor.grumpy.BBTree.CreatePerlStyleBooleanFlag" href="#coinor.grumpy.BBTree.CreatePerlStyleBooleanFlag">CreatePerlStyleBooleanFlag</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.parse_options" href="#coinor.grumpy.BBTree.parse_options">parse_options</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="coinor.grumpy.BBTree.BBTree" href="#coinor.grumpy.BBTree.BBTree">BBTree</a></code></h4>
<ul class="">
<li><code><a title="coinor.grumpy.BBTree.BBTree.AddOrUpdateNode" href="#coinor.grumpy.BBTree.BBTree.AddOrUpdateNode">AddOrUpdateNode</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.AddProgressMeasures" href="#coinor.grumpy.BBTree.BBTree.AddProgressMeasures">AddProgressMeasures</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.AdjustHistogramEndBins" href="#coinor.grumpy.BBTree.BBTree.AdjustHistogramEndBins">AdjustHistogramEndBins</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.CreateAnimatedImages" href="#coinor.grumpy.BBTree.BBTree.CreateAnimatedImages">CreateAnimatedImages</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GenerateAllIncumbentPaths" href="#coinor.grumpy.BBTree.BBTree.GenerateAllIncumbentPaths">GenerateAllIncumbentPaths</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GenerateForecastImages" href="#coinor.grumpy.BBTree.BBTree.GenerateForecastImages">GenerateForecastImages</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GenerateHistogram" href="#coinor.grumpy.BBTree.BBTree.GenerateHistogram">GenerateHistogram</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GenerateIncumbentPath" href="#coinor.grumpy.BBTree.BBTree.GenerateIncumbentPath">GenerateIncumbentPath</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GeneratePredictionImages" href="#coinor.grumpy.BBTree.BBTree.GeneratePredictionImages">GeneratePredictionImages</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GenerateScatterplot" href="#coinor.grumpy.BBTree.BBTree.GenerateScatterplot">GenerateScatterplot</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GenerateTreeImage" href="#coinor.grumpy.BBTree.BBTree.GenerateTreeImage">GenerateTreeImage</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GetImageCounterString" href="#coinor.grumpy.BBTree.BBTree.GetImageCounterString">GetImageCounterString</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GetImageObjectiveBounds" href="#coinor.grumpy.BBTree.BBTree.GetImageObjectiveBounds">GetImageObjectiveBounds</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GetTreeFixedHorizontalPositions" href="#coinor.grumpy.BBTree.BBTree.GetTreeFixedHorizontalPositions">GetTreeFixedHorizontalPositions</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.GetTreeHorizontalPositions" href="#coinor.grumpy.BBTree.BBTree.GetTreeHorizontalPositions">GetTreeHorizontalPositions</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.IsBetterThan" href="#coinor.grumpy.BBTree.BBTree.IsBetterThan">IsBetterThan</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.IsBetterThanIncumbent" href="#coinor.grumpy.BBTree.BBTree.IsBetterThanIncumbent">IsBetterThanIncumbent</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessBranchedLine" href="#coinor.grumpy.BBTree.BBTree.ProcessBranchedLine">ProcessBranchedLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessCandidateLine" href="#coinor.grumpy.BBTree.BBTree.ProcessCandidateLine">ProcessCandidateLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessFathomedLine" href="#coinor.grumpy.BBTree.BBTree.ProcessFathomedLine">ProcessFathomedLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessHeuristicLine" href="#coinor.grumpy.BBTree.BBTree.ProcessHeuristicLine">ProcessHeuristicLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessInfeasibleLine" href="#coinor.grumpy.BBTree.BBTree.ProcessInfeasibleLine">ProcessInfeasibleLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessIntegerLine" href="#coinor.grumpy.BBTree.BBTree.ProcessIntegerLine">ProcessIntegerLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessLine" href="#coinor.grumpy.BBTree.BBTree.ProcessLine">ProcessLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.ProcessPregnantLine" href="#coinor.grumpy.BBTree.BBTree.ProcessPregnantLine">ProcessPregnantLine</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.RunGnuplotOnAllFiles" href="#coinor.grumpy.BBTree.BBTree.RunGnuplotOnAllFiles">RunGnuplotOnAllFiles</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.UpdateObjectiveValueLimits" href="#coinor.grumpy.BBTree.BBTree.UpdateObjectiveValueLimits">UpdateObjectiveValueLimits</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.WriteAllIncumbentPathsScript" href="#coinor.grumpy.BBTree.BBTree.WriteAllIncumbentPathsScript">WriteAllIncumbentPathsScript</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.WriteDataFileFromList" href="#coinor.grumpy.BBTree.BBTree.WriteDataFileFromList">WriteDataFileFromList</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.WriteHistogramScript" href="#coinor.grumpy.BBTree.BBTree.WriteHistogramScript">WriteHistogramScript</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.WriteIncumbentPathScript" href="#coinor.grumpy.BBTree.BBTree.WriteIncumbentPathScript">WriteIncumbentPathScript</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.WriteScatterplotScript" href="#coinor.grumpy.BBTree.BBTree.WriteScatterplotScript">WriteScatterplotScript</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.WriteTreeScript" href="#coinor.grumpy.BBTree.BBTree.WriteTreeScript">WriteTreeScript</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.display" href="#coinor.grumpy.BBTree.BBTree.display">display</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.display_all" href="#coinor.grumpy.BBTree.BBTree.display_all">display_all</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.display_image" href="#coinor.grumpy.BBTree.BBTree.display_image">display_image</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.process_file" href="#coinor.grumpy.BBTree.BBTree.process_file">process_file</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.set_display_mode" href="#coinor.grumpy.BBTree.BBTree.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.set_edge_limit" href="#coinor.grumpy.BBTree.BBTree.set_edge_limit">set_edge_limit</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.set_fathom" href="#coinor.grumpy.BBTree.BBTree.set_fathom">set_fathom</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.set_label" href="#coinor.grumpy.BBTree.BBTree.set_label">set_label</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.set_logscaley" href="#coinor.grumpy.BBTree.BBTree.set_logscaley">set_logscaley</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.set_sample_tree" href="#coinor.grumpy.BBTree.BBTree.set_sample_tree">set_sample_tree</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.write_as_dynamic_gexf" href="#coinor.grumpy.BBTree.BBTree.write_as_dynamic_gexf">write_as_dynamic_gexf</a></code></li>
<li><code><a title="coinor.grumpy.BBTree.BBTree.write_image" href="#coinor.grumpy.BBTree.BBTree.write_image">write_image</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
